{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"moteus Brushless Servo Documentation","text":"<p>Welcome to the documentation site for the moteus brushless motor controller.</p>"},{"location":"#what-is-moteus","title":"What is moteus?","text":"<p>moteus controllers are high-performance modular brushless motor controllers with integrated on-axis magnetic encoders, designed for robotics applications. They feature:</p> <ul> <li>Field Oriented Control (FOC) for 3-phase brushless motors</li> <li>Integrated magnetic encoder for precise position sensing</li> <li>High-speed CAN-FD communication at 5Mbps</li> <li>Multiple control modes: Position, velocity, and torque control with acceleration and velocity limited trajectories</li> <li>Fast control loops running at 15-30kHz</li> </ul>"},{"location":"#hardware-variants","title":"Hardware Variants","text":"Name Voltage Input Peak Power Mass Dimensions r4.11 10-44V 900W @ 30V 14.2g 46x53mm c1 10-51V 250W @ 28V 8.9g 38x38x9mm n1 10-54V 2kW @ 36V 14.6g 46x46x8mm x1 10-54V 1.3kW @ 36V 23.8g 56x56x10mm <p>Assembled and tested boards can be purchased at mjbots.com</p>"},{"location":"#documentation","title":"Documentation","text":"<ul> <li>Quick Start</li> <li>Using Moteus</li> <li>Integration</li> <li>Troubleshooting</li> <li>Reference</li> </ul>"},{"location":"#community-support","title":"Community &amp; Support","text":"<ul> <li>Discord Community</li> <li>GitHub Repository</li> <li>Purchase Hardware</li> </ul>"},{"location":"#license","title":"License","text":"<p>All files in this repository are available under the Apache 2.0 License.</p> <p>Trademark Notice</p> <p>mjbots Robotic Systems LLC owns and protects the \"mjbots\" and \"moteus\" trademarks. Please read the Trademark Policy if you want to use these names in your project.</p>"},{"location":"quick-start/","title":"Quick Start Guide","text":"<p>New to moteus?  Work through these sections in order.  The first set is if you have a bare board, the second is if you are starting from a developer kit.</p>"},{"location":"quick-start/#setup-overview-for-bare-boards","title":"Setup Overview for Bare Boards","text":"<p>If you have a bare moteus board and a motor, these steps are for you.</p> <ol> <li>Mechanical Setup - Mount the encoder magnet and controller</li> <li>Electrical Setup - Connect phase wires and power</li> <li>Software Installation - Install and run tview</li> <li>Configuration - Set essential parameters</li> <li>Encoder Overview - Understand encoder options (if using external encoders)</li> <li>Calibration - Calibrate the controller for your motor</li> <li>PID Tuning - Tune the position control constants</li> <li>Control Modes - Learn how to control the motor</li> </ol>"},{"location":"quick-start/#developer-kit-users","title":"Developer Kit Users","text":"<p>If you're starting from a developer kit, the motor is already mounted, configured, calibrated and tuned. Your job is easier, yay!  Just follow these steps:</p> <ol> <li>Software Installation - Install tview</li> <li>Control Modes - Start controlling your motor</li> </ol>"},{"location":"quick-start/#need-help","title":"Need Help?","text":"<ul> <li>Troubleshooting - Common issues and solutions</li> <li>Discord Community - Get help from the community</li> <li>GitHub Issues - Report bugs or request features</li> <li>info@mjbots.com - Email support</li> </ul>"},{"location":"reference/","title":"Reference Documentation","text":"<p>This page has been reorganized. Please use the navigation menu or the links below to find the content you're looking for.</p>"},{"location":"reference/#quick-links","title":"Quick Links","text":""},{"location":"reference/#theory-and-operation","title":"Theory and Operation","text":"<p> Theory of Operation - Controller architecture and control laws</p> <p> Usage Modes / Control Modes - Position, velocity, and torque control modes</p>"},{"location":"reference/#configuration","title":"Configuration","text":"<p> Initial Parameters / Configuration - Getting started with configuration</p> <p> Encoder Configuration - Encoder setup and configuration</p> <p> Auxiliary Port - Auxiliary connector configuration and pinouts</p> <p> AUX1/ENC Pins - r4.11 AUX1/ENC connector pinout</p> <p> AUX2/ABS Pins - r4.11 AUX2/ABS connector pinout</p> <p> AUX GPIO Output Control - Setting GPIO outputs via diagnostic commands</p> <p> AUX UART Mode - Configuring UART on auxiliary ports</p> <p> Pin Capabilities - Available pin modes and configurations</p>"},{"location":"reference/#configuration-parameters","title":"Configuration Parameters","text":"<p> id.id - Device ID configuration</p> <p> servo.default_timeout_s - Command timeout configuration</p> <p> servo.flux_brake_margin_voltage - Flux braking voltage threshold</p> <p> servo.max_power_W - Maximum power limit</p> <p> servo.pid_position - Position PID controller parameters</p> <p> servopos.position_min - Minimum position limit</p> <p> motor_position.output.offset/sign - Output encoder offset and sign</p> <p> motor_position.rotor_to_output_ratio - Gear reduction ratio</p> <p> Configuration Commands - Reading and writing configuration via console</p>"},{"location":"reference/#register-reference","title":"Register Reference","text":"<p> 0x000 - Mode - Operational mode register</p> <p> 0x00f - Fault Code - Fault status register</p> <p> 0x014/0x15/0x16 - Voltage Phase A/B/C - Phase voltage control registers</p> <p> 0x020 - Position Command - Position setpoint register</p> <p> 0x021 - Velocity Command - Velocity setpoint register</p> <p> 0x023 - Kp Scale - Proportional gain scaling</p> <p> 0x025 - Maximum Torque - Torque limit register</p> <p> 0x028 - Velocity Limit - Trajectory velocity limit</p> <p> 0x058 - Encoder Validity - Encoder status bitfield</p> <p> 0x05c - Aux1 GPIO Command - GPIO output control register</p> <p> 0x070 - Millisecond Counter - System timestamp register</p> <p> 0x131 - Set Output Exact - Force absolute position register</p> <p> 0x150-0x153 - UUID - Device UUID registers</p> <p> 0x154-0x157 - UUID Mask - UUID filtering registers</p> <p> Register Mappings - Data type encodings and scaling</p> <p> Register List - Complete register documentation</p>"},{"location":"reference/#can-protocol","title":"CAN Protocol","text":"<p> CAN Format - CAN-FD frame structure</p> <p> Write Registers - Register write subframe format</p> <p> CAN Protocol Example - Sample CAN frame breakdown</p> <p> Sending Multiple Commands - Batching commands in tview</p> <p> Communicating with Specific Device - Targeting devices by ID</p> <p> CAN Bit Timings - socketcan bitrate configuration</p> <p> Clock-Specific Bit Timings - 40MHz and 80MHz configurations</p>"},{"location":"reference/#diagnostic-commands","title":"Diagnostic Commands","text":"<p> Diagnostic Protocol - Console command reference</p> <p> d pwm - Raw PWM control command</p> <p> d nearest - Set output nearest command</p> <p> d cfg-set-output - Configure output encoder</p>"},{"location":"reference/#hardware-reference","title":"Hardware Reference","text":"<p> Pinouts - Connector pinouts for all board variants</p> <p> Debug Port (JST ZH-6) - SWD debug connector</p> <p> n1/c1 AUX2 (JST GH-7) - n1 and c1 auxiliary port connector</p> <p> r4 ABS (JST ZH-4) - r4 absolute encoder connector</p> <p> r4 ENC (Pico-SPOX-6) - r4 incremental encoder connector</p> <p>Hardware Specifications - Electrical ratings and mechanical information</p> <p>Application Limits - Position, velocity, and performance constraints</p>"},{"location":"reference/#calibration-and-tuning","title":"Calibration and Tuning","text":"<p> Calibration - Motor and encoder calibration procedures</p> <p> PID Tuning - Controller tuning methodology</p>"},{"location":"reference/#firmware-and-tools","title":"Firmware and Tools","text":"<p> Flashing and Building Firmware - Firmware compilation and installation</p> <p> tview Usage - Command-line tool documentation</p>"},{"location":"reference/#deployment","title":"Deployment","text":"<p> Deployment Considerations - Production design guidelines and safety considerations</p>"},{"location":"reference/#additional-topics","title":"Additional Topics","text":"<p> Hall Effect Sensors - Using motors with hall effect sensors or configuring hall sensor pins</p> <p> Position Mode - Position control details</p> <p> Torque Control - Direct torque control mode</p>"},{"location":"guides/calibration/","title":"Calibration","text":"<p>If you started from a bare moteus board, you will need to calibrate it for the attached motor before any control modes are possible. Calibration is required when:</p> <ul> <li>Using a new bare moteus controller for the first time</li> <li>Changing to a different motor</li> <li>Altering the mechanical registration between the controller and motor</li> <li>After certain configuration changes that affect motor characteristics</li> </ul> <p>Development kits typically come pre-calibrated and do not require this step unless the motor is changed.</p>"},{"location":"guides/calibration/#calibration-command","title":"Calibration Command","text":"<p>To calibrate your moteus controller, run the following command:</p> <pre><code>python3 -m moteus.moteus_tool --target 1 --calibrate\n</code></pre> <p>Replace <code>1</code> with the appropriate CAN-FD ID if you have configured your controller to use a different ID.</p>"},{"location":"guides/calibration/#important-safety-warning","title":"Important Safety Warning","text":"<p>WARNING: Any attached motor must be able to spin freely during calibration.</p> <p>During the calibration process:</p> <ul> <li>The motor will be spun in both directions</li> <li>The motor will reach high speeds</li> <li>Ensure no mechanical obstructions are present</li> <li>Do not apply any load to the motor shaft</li> <li>Keep hands and objects clear of the motor and any attached mechanisms</li> </ul> <p>The calibration procedure measures motor electrical characteristics and encoder alignment, which requires unrestricted motor motion.</p>"},{"location":"guides/calibration/#alternate-calibration-parameters","title":"Alternate calibration parameters","text":""},{"location":"guides/calibration/#limited-rotation","title":"Limited rotation","text":"<p>The amount of motion required for calibration can be reduced if the Kv of the motor is known in advance.  In that case, specify as an additional command line argument:</p> <p><code>--cal-force-kv X</code></p> <p>Where X is the Kv of the motor.  In this mode, moteus will only spin the rotor 360 degrees in each direction and will not perform a high speed movement.</p>"},{"location":"guides/calibration/#very-small-or-very-large-motors","title":"Very small or very large motors","text":"<p>During the encoder calibration process, moteus applies a constant power to the motor.  The default power, 7.5W is sufficient for many motors but not all.  If the motor is very small, it could overheat or burn if applying that much power.  If the motor is very large, 7.5W may not be enough to cause the motor to move.  This can be altered by specifying:</p> <p><code>--cal-motor-power X</code></p> <p>Where X is the power in watts to apply.  Small motors will need smaller values, large motors may need larger ones.</p>"},{"location":"guides/calibration/#updating-encoder-and-torque-bandwidth","title":"Updating encoder and torque bandwidth","text":"<p>If your application requires changing torque or velocity very quickly, you may want to configure an alternate \"bandwidth\" parameter during the calibration process.  The specific value of bandwidth can be roughly used to estimate how quickly moteus can change the output torque, and how quickly it can sense velocity and position changes.  For instance, the default bandwidth is 200Hz.  This means that as a rough order of magnitude, moteus can change the torque or observe a change in velocity in 1/200 = 5ms.  Higher bandwidth values will result in the controller and motor emitting more audible noise.  Other than audible noise (which can be significant), there is not much downside to increasing the bandwidth.</p> <p><code>--cal-bw-hz X</code></p>"},{"location":"guides/calibration/#troubleshooting","title":"Troubleshooting","text":"<p>If you encounter issues during calibration, such as:</p> <ul> <li>Motor not spinning</li> <li>Calibration failures or errors</li> <li>Unexpected motor behavior</li> </ul> <p>Refer to the Troubleshooting Guide for common problems and solutions.</p>"},{"location":"guides/calibration/#next-steps","title":"Next Steps","text":"<p>After successful calibration, you can conduct the PID tuning process:</p> <ul> <li>PID Tuning</li> </ul>"},{"location":"guides/configuration/","title":"Configuration","text":"<p>Before using a moteus controller for the first time, it is necessary to configure several key parameters. These parameters define operational limits, control behavior, and configure the system to match your specific application.</p>"},{"location":"guides/configuration/#essential-configuration-parameters","title":"Essential Configuration Parameters","text":"<p>The following parameters should be reviewed and will likely need to configured in a customized way for nearly every application.</p>"},{"location":"guides/configuration/#position-limits","title":"Position Limits","text":"<p><code>servopos.position_min</code> and <code>servopos.position_max</code></p> <p>These define the bounds of motion which the controller will allow when in position control mode. Attempting to start beyond this region will fault, and if outside the region during operation, no torque will be applied to move further outside these limits.  If they are unwanted, <code>nan</code> should be used to disable them.</p>"},{"location":"guides/configuration/#current-limits","title":"Current Limits","text":"<p><code>servo.max_current_A</code></p> <p>The maximum phase current to apply to the motor. This can be used to limit the maximum torque that the system is capable of producing, regardless of any command sent. Set this based on your motor's peak current rating and thermal capabilities.</p>"},{"location":"guides/configuration/#velocity-limits","title":"Velocity Limits","text":"<p><code>servo.max_velocity</code></p> <p>Limits the maximum speed the motor is permitted to achieve before no torque is produced. This acts as a safety limit to prevent excessive speeds that could damage the motor or mechanical system.</p> <p><code>servo.default_velocity_limit</code> / <code>servo.default_accel_limit</code></p> <p>Controls how fast the motor can accelerate and spin in order to reach position and velocity targets. Bare boards ship with these unset, while development kits ship with human-eye pleasing values. Adjust these to match your application's performance requirements.</p>"},{"location":"guides/configuration/#gearbox-scaling","title":"Gearbox Scaling","text":"<p><code>motor_position.rotor_to_output_ratio</code></p> <p>A gearbox scaling factor. A reducing gearbox should be configured with a number smaller than one (e.g., 0.25 for a 4x reduction gearbox). This affects reported position, speed, and torques, scaling them to represent the output shaft values rather than motor shaft values.</p>"},{"location":"guides/configuration/#device-identification","title":"Device Identification","text":"<p><code>id.id</code></p> <p>The CAN-FD ID used by this device. Each controller on the bus must have a unique ID. Valid IDs range from 1 to 126.  If you set this to a value other than 1, be aware that unless your tview and controller firmware are newer than late 2025, you will need to restart tview with:</p> <pre><code>python -m moteus_gui.tview -t N\n</code></pre> <p>Where N is the new ID, in order to issue a <code>conf write</code> to save the parameters.</p>"},{"location":"guides/configuration/#pid-parameters","title":"PID Parameters","text":"<p><code>servo.pid_position</code></p> <p>The PID parameters for the position control loop. It will be necessary to tune these, it isn't hard, although it must be done after calibration is performed. You'll get to the PID Tuning guide after completing the calibration process.</p>"},{"location":"guides/configuration/#saving-parameters","title":"Saving parameters","text":"<p>All parameters (including the ID) are temporarily stored in volatile memory that will be discarded after a power cycle.  To save those parameters to persistent storage, it is necessary to type:</p> <pre><code>conf write\n</code></pre> <p>Into the diagnostic console of tview.</p>"},{"location":"guides/configuration/#additional-configuration","title":"Additional Configuration","text":"<p>A larger set of parameters is documented in the Configuration Parameters Reference, covering advanced features such as:</p> <ul> <li>Motor electrical characteristics</li> <li>Encoder configuration</li> <li>Temperature limits</li> <li>Communication settings</li> <li>Advanced control parameters</li> </ul>"},{"location":"guides/configuration/#next-steps","title":"Next Steps","text":"<p>After configuring these essential parameters, you should familiarize yourself with the encoder system and position feedback:</p> <ul> <li>Encoder Overview</li> </ul>"},{"location":"guides/control-modes/","title":"Control Modes","text":"<p>The moteus controller offers flexible control modes to suit different robotics applications. By adjusting control gains and command parameters, you can optimize the controller for various use cases\u2014from precise positioning and velocity control to high-bandwidth torque applications. This guide covers the recommended configurations for common control scenarios.</p>"},{"location":"guides/control-modes/#understanding-position-mode","title":"Understanding Position Mode","text":"<p>The primary control mode for the moteus controller is an integrated position/velocity controller. The semantics of the control command are somewhat unorthodox, so as to be easily amenable to idempotent commands sent from a higher level controller. Each command includes the following parameters:</p> <ul> <li>Position: The desired position in revolutions</li> <li>Velocity: The rate at which the desired position changes in revolutions/s</li> <li>Maximum torque: Never use more than this amount of torque when controlling</li> <li>Feedforward torque: Give this much extra torque beyond what the normal control loop says</li> <li>Stop position: If non-special, never move the desired position away from this target</li> <li>kp scale: Scale the proportional constant by this factor</li> <li>kd scale: Scale the derivative constant by this factor</li> <li>ilimit scale: Scale the integrative limit by this factor</li> <li>Velocity limit override: If non-special, override the configured velocity limit, which constrains how quickly the target position is reached</li> <li>Acceleration limit override: If non-special, override the configured acceleration limit, which constrains how quickly the target position is reached</li> </ul> <p>Additionally, the position may be set as a \"special value\" (NaN for floating point and the debug interface, maximal negative for integer encodings). In that case, the position selected is \"wherever you are right now\".</p> <p>A pure velocity mode can be obtained by setting the kp scale to 0 (or permanently so by configuring the kp constant to 0). In this case, using the <code>servo.max_position_slip</code> configurable parameter may be valuable as per the velocity control section below.</p>"},{"location":"guides/control-modes/#constant-acceleration-trajectories","title":"Constant Acceleration Trajectories","text":"<p>Velocity and acceleration limits can be configured either globally, or on a per-command basis which will cause moteus to internally generate continuous acceleration limited trajectories to reach the given position and velocity.  Once the trajectory is complete, the command velocity is continued indefinitely.</p> Diagnostic ProtocolPythonC++ <pre><code># Move to position 1 then stop.  Accelerate/decelerate at 2Hz/s\n# and use a maximum velocity of 0.5Hz.\nd pos 1 0 nan a2 v0.5\n</code></pre> <pre><code>await controller.set_position(\n    position=1,\n    velocity=0,\n    accel_limit=2,\n    velocity_limit=0.5,\n)\n</code></pre> <pre><code>mjbots::moteus::Controller::Options options;\noptions.position_format.accel_limit = mjbots::moteus::kFloat;\noptions.position_format.velocity_limit = mjbots::moteus::kFloat;\n\nmjbots::moteus::Controller controller(options);\n\nmjbots::moteus::PositionMode::Command cmd;\ncmd.position = 1.0;\ncmd.velocity = 0.0;\ncmd.accel_limit = 2.0;\ncmd_velocity_limit = 0.5;\n\nauto result = controller.SetPosition(cmd);\n</code></pre> <p>Default values for acceleration and velocity limits can also be set in configuration.</p> <ul> <li><code>servo.default_accel_limit</code></li> <li><code>servo.default_velocity_limit</code></li> </ul>"},{"location":"guides/control-modes/#velocity-control","title":"Velocity Control","text":"<p>To implement a velocity controller, each command should have the \"position\" set to NaN (or equivalent integral encoding).  It is recommended to configure <code>servo.max_position_slip</code> to a finite value greater than or equal to 0 (reference). When it is larger, more external disturbances will be rejected, but the controller will also \"catch up\" when the magnitude of external disturbances is decreased.</p> <p>Example:</p> Diagnostic ProtocolPythonC++ <pre><code>d pos nan 2 nan\n</code></pre> <pre><code>await controller.set_position(\n    position=math.nan,  # NaN for velocity mode\n    velocity=2.0,       # 2 revolutions/second\n    query=True\n)\n</code></pre> <pre><code>mjbots::moteus::PositionMode::Command cmd;\ncmd.position = std::numeric_limits&lt;double&gt;::quiet_NaN();\ncmd.velocity = 2.0;  // 2 revolutions/second\n\nauto result = controller.SetPosition(cmd);\n</code></pre>"},{"location":"guides/control-modes/#torque-control","title":"Torque Control","text":"<p>For a pure torque control application, the PID gains of the position control loop must be set to 0.  One way to accomplish that is by sending the <code>kp_scale</code>, <code>kd_scale</code>, and <code>ilimit_scale</code> values to 0.</p> Diagnostic ProtocolPythonC++ <pre><code># Command a torque of 0.1 Nm\nd pos nan 0 nan p0 d0 i0 f0.1\n</code></pre> <pre><code>await controller.set_position(\n    position=math.nan,\n    velocity=0,\n    kp_scale=0.0,\n    kd_scale=0.0,\n    ilimit_scale=0.0,\n    feedforward_torque=0.1,\n)\n</code></pre> <pre><code>mjbots::moteus::Controller::Options options;\noptions.position_format.kp_scale = mjbots::moteus::kFloat;\noptions.position_format.kd_scale = mjbots::moteus::kFloat;\noptions.position_format.ilimit_scale = mjbots::moteus::kFloat;\noptions.position_format.feedforward_torque = mjbots::moteus::kFloat;\n\nmjbots::moteus::Controller controller(options);\n\nmjbots::moteus::PositionMode::Command cmd;\ncmd.position = std::numeric_limits&lt;double&gt;::quiet_NaN();\ncmd.velocity = 0.0;\ncmd.kp_scale = 0.0;\ncmd.kd_scale = 0.0;\ncmd.ilimit_scale = 0.0;\ncmd.feedforward_torque = 0.1;\n\nauto result = controller.SetPosition(cmd);\n</code></pre> <p>Caveat: Using external torque control will be much lower bandwidth than using the internal position controller of moteus (~15x lower bandwidth if maximal CAN-FD update rate is achieved).  Thus, a system will usually perform better if as much of the desired control law as possible is formulated in terms of the built in position controller.</p> <p>If the system will never perform anything but torque control, then the PID gains can be set to 0 in configuration.</p> <ul> <li><code>servo.pid_position.kp</code></li> <li><code>servo.pid_position.kd</code></li> <li><code>servo.pid_position.ilimit</code></li> </ul>"},{"location":"guides/control-modes/#jerk-limited-trajectories","title":"Jerk Limited Trajectories","text":"<p>moteus only supports acceleration limited internal trajectories.  To approximate a constant jerk trajectory, the host processor should send a sequence of piecewise linear constant velocity trajectories which approximate the desired one.  This would be done by sending commands consisting of at least a position and velocity at some moderate to high rate while disabling the internal velocity and acceleration limits.</p>"},{"location":"guides/control-modes/#low-speed-or-precise-positioning","title":"Low Speed or Precise Positioning","text":"<p>For either operation at very low speeds, or when precise positioning performance is desired, it is recommended to configure a non-zero <code>ki</code> and <code>ilimit</code> term in the position controller (reference).  This will compensate for cogging torque (at the expense of overall torque bandwidth).  It may also be beneficial to select a higher value for calibration bandwidth.</p>"},{"location":"guides/dual-encoders/","title":"Dual Encoder Configuration","text":"<p>Often moteus is used in applications where a gearbox or other reducer is used between the rotor and the final plant.  In those situations it can be valuable to have a secondary encoder measuring the output of the reducer:</p> <p>Absolute positioning: With only an encoder on the rotor, it is not possible to know absolutely where the output is.</p> <p>Improved accuracy or sensing performance: The onboard encoder included with moteus is sufficient for commutation for nearly all motors, however some applications may require lower position or velocity sensing noise or higher resolution in order to achieve accurate very slow movements, or very accurate positioning.</p> <p>This section will cover how to set up several common dual encoder configurations.</p>"},{"location":"guides/dual-encoders/#important-factors-when-configuring-dual-encoders","title":"Important factors when configuring dual encoders","text":"<ol> <li> <p>Sign match: moteus requires that the sign of all encoders match.  Those must be configured manually in <code>motor_position.sources.X.sign</code>.  To verify the signs are correct, plot <code>motor_position.sources.X.filtered_value</code> for all configured encoders, spin the system by hand, and verify that all plots move in the same direction.</p> </li> <li> <p>Offset match: If the absolute values of multiple encoders must be related, such as for a disambiguation configuration, then the offsets must be matched so that the encoders read 0 at the same time.  These offsets must be manually configured in <code>motor_position.sources.X.offset</code>.  To verify they are correct, plot <code>motor_position.sources.X.filtered_value</code> for all configured encoders, spin the system by hand to the zero point, and verify that all encoders read 0.</p> </li> </ol>"},{"location":"guides/dual-encoders/#onboard-8x-reducer-ma600-on-axis-disambiguation","title":"Onboard + 8x reducer + MA600 on-axis - Disambiguation","text":"<p>In this configuration, the rotor is sensed with the moteus onboard encoder and the output is sensed with an MA600 on-axis encoder.  Assuming low backlash, the output positioning is performed from the onboard encoder and the output encoder is only used for disambiguation.  This results in the best performance since the effective resolution of the onboard encoder is multiplied by the gear reduction and will be much better than the MA600 on the output.</p> <p>The MA600 is attached to the aux2 port on one of the moteus-c1 (c1 pinout), moteus-n1 (n1 pinout), or moteus-x1 (x1 pinout).</p> <p>This pinout is the one accomplished if using the cable included with the mjbots MA600 breakout board.</p> <p>If starting from a factory default configuration, first, configure the aux2 port:</p> <pre><code>aux2.pins.0.mode 1  # spi\naux2.pins.1.mode 1  # spi\naux2.pins.2.mode 1  # spi\naux2.pins.3.mode 2  # spi_cs\naux2.spi.mode 5     # ma600\naux2.spi.rate_hz 6000000\n</code></pre> <p>Then, configure motor_position:</p> <pre><code>motor_position.sources.1.aux_number 2\nmotor_position.sources.1.type 1\nmotor_position.sources.1.cpr 65536\nmotor_position.sources.1.reference 1  # output\nmotor_position.rotor_to_output_ratio 0.125\nmotor_position.output.reference_source 1\n</code></pre> <p>The sign and offset of the MA600 will need to be matched to the onboard encoder as per the above section.</p>"},{"location":"guides/dual-encoders/#onboard-10x-reducer-aksim-2-on-output","title":"Onboard + 10x reducer + AksIM-2 on output","text":"<p>In this configuration, the onboard encoder is used to sense the rotor, and an AksIM-2 encoder from RLS is used on the output.  The AksIM-2 has much better accuracy and noise performance than the onboard on-axis encoder, and thus this configuration could be used for applications where either very accurate positioning is required, or very precise low speeds are required.</p> <p>The AksIM-2 is attached to the GH-6 RS422 connector on a moteus-n1 (n1 pinout) or moteus-x1 (x1 pinout).</p> <p>moteus is compatible with AksIM-2 encoders configured as follows:</p> <ul> <li>Communication Interface: SF - Asynchronous Serial, RS422, 5V</li> <li>Communication Protocol Variant: F - 1000 kbps</li> <li>Resolution: &lt;= 19B, no multiturn support</li> </ul> <p>If starting from a factory default configuration, first configure the aux1 port.</p> <pre><code>aux1.pins.4.mode 3 # uart\naux1.pins.5.mode 3 # uart\naux1.uart.mode 2 # aksim2\naux1.uart.baud_rate 1000000\naux1.uart.rs422 1\n</code></pre> <p>Then configure motor_position:</p> <pre><code>motor_position.rotor_to_output_ratio 0.1\nmotor_position.sources.1.aux_number 1\nmotor_position.sources.1.type 2          # uart\nmotor_position.sources.1.cpr 4194304     # used by moteus for all AksIM-2\nmotor_position.sources.1.reference 1     # output\nmotor_position.output_source 1\n</code></pre> <p>The sign and offset of the AksIM-2 will need to be matched to the onboard encoder as per the above section.</p>"},{"location":"guides/dual-encoders/#hall-10x-reducer-off-axis-ma600","title":"Hall + 10x reducer + Off axis MA600","text":"<p>In this configuration, hall effect encoders are used to sense commutation and an MA600 is used in conjuction with a diametrically magnetized ring magnet for output positioning.  It is designed as one of the lowest cost options for a hollow axis actuator with a gear reduction, as the off-axis MA600 has minimally acceptable performance as does the hall effect sensors.</p> <p>The MA600 is connected to AUX1 on a moteus-n1 (n1 pinout) or moteus-x1 (x1 pinout) and the hall effect sensors are connected to AUX2.</p> <p>First, we will configure the hall effect sensors and calibrate them.</p> <pre><code>aux2.pins.0.mode 6  # hall\naux2.pins.0.pull 1  # pull_up\naux2.pins.1.mode 6  # hall\naux2.pins.1.pull 1  # pull_up\naux2.pins.2.mode 6  # hall\naux2.pins.2.pull 1  # pull_up\naux2.hall.enabled 1\nmotor_position.rotor_to_output_ratio 0.1\nmotor_position.sources.0.aux_number 2\nmotor_position.sources.0.type 4  # hall\n</code></pre> <p>Then, the hall effect sensors are calibrated:</p> <pre><code>python -m moteus.moteus_tool -t 1 --calibrate --cal-motor-poles 30\n</code></pre> <p>Now we will configure the MA600.</p> <pre><code>aux1.pins.0.mode 1  # spi\naux1.pins.1.mode 1  # spi\naux1.pins.2.mode 1  # spi\naux1.pins.3.mode 2  # spi_cs\naux1.spi.mode 5     # ma600\naux1.spi_rate_hz 6000000\nmotor_position.sources.1.aux_number 1\nmotor_position.sources.1.type 1  # spi\nmotor_position.sources.1.cpr 65536\nmotor_position.sources.1.reference 1  # output\n</code></pre> <p>Then, before configuring the MA600 to be used for output, match the sign of the MA600 and hall effects according to the procedure here.</p> <p>For an off-axis MA600, BCT tuning should be performed, and non-linear compensation may be performed.</p> <pre><code>moteus$ ./utils/measure_ma732_bct.py\n</code></pre> <p>To peform non-linear compensation, you can use:</p> <pre><code>moteus$ ./utils/compensate_encoder.py\n</code></pre> <p>Finally, the MA600 can be configured as the output source:</p> <pre><code>motor_position.output.source 1\n</code></pre>"},{"location":"guides/electrical-setup/","title":"Electrical Setup","text":"<p>To use moteus without damage, proper care must be paid to the electrical connections and configuration.  This section describes how.</p>"},{"location":"guides/electrical-setup/#electrical-connections","title":"Electrical Connections","text":"<p>Motor: Phase wires for the motor should be soldered to the pads labeled A, B, and C. The order does not matter. The location of the pads varies between controllers.  An inline connector, like an MR30, MR60, or bullet connectors can be used if repeated disconnection is desired.</p> <p>Power: Power is provided via either the onboard XT30 connector, or on board-mountable moteus controllers, via the power pads that are interleaved with the A, B, and C phase pads.  The power input is NOT protected against reverse polarity.  Polarity should be triple checked before applying power, or irreversible damage may result.  XT30 connectors have a clear '+' and '-' marking on them which can be used to identify the positive and negative input.</p> <p>If you are unsure, pinout diagrams for all controllers can be found here: Pinout diagrams</p> <p>Hot plugging</p> <p>It is important to never hot plug an XT30 connector.  The XT30 connector (and all connectors which are not anti-spark), should be connected before power is applied.  If you see or hear a spark, you have applied power in the wrong order.  See the below section on inrush current management.</p>"},{"location":"guides/electrical-setup/#soldering-and-cable-construction-techniques","title":"Soldering and cable construction techniques","text":"<p>moteus controllers can be damaged when improper techniques are used to attach wires to them, or improper techniques are used to construct power cables.</p>"},{"location":"guides/electrical-setup/#phase-wire-soldering","title":"Phase Wire Soldering","text":"<p>The connections between moteus and the motor under control must be high quality.  Poor quality solder joints can cause intermittent changes in resistance, sparking, and high voltage transients.  High quality solder joints require:</p> <ul> <li>Sufficient flux to clean oxides off of the wire and the via</li> <li>Sufficient temperature so that the entire wire and via is hot enough for the solder to wet all surfaces</li> </ul> <p>For the former, it is often necessary to add copious amounts of additional flux in addition to the rosin core inside many solders.  For the latter, a high power soldering iron, with a fat tip, and what seems like a long time may be necessary.  The temperature is definitely insufficient if solder touched to any part of the via or wire does not melt and wick instantly.  Usually a small amount of solder is placed between the tip and wire to act as a heat transfer agent.  Then the iron rests on the via and wire for between 5-30s until it looks like the initial solder has wicked fully into the via.  Then additional solder can be added until it forms a clean smooth fillet around the entire via wicking up to the wire.</p> <p>When complete, the back side of the hole can be examined, and if successful, solder will have wicked partially down out of the via onto the other side forming a clean, smooth fillet there as well.</p> <p>A demonstration of this can be found in the following video: https://www.youtube.com/watch?v=mZ9w_TaWmjQ</p>"},{"location":"guides/electrical-setup/#power-cable-construction","title":"Power Cable Construction","text":"<p>When constructing power cables using XT30 connectors, it is critical that solder joints be sound, otherwise intermittent connectivity can result.  This can cause sparking and high voltage transients.  The soldering principles are the same as in the phase wire soldering section above.</p> <p>A demonstration of XT30 soldering can be found in the following video: https://www.youtube.com/watch?v=f6WtDFWuxuQ</p>"},{"location":"guides/electrical-setup/#power-connectorization","title":"Power Connectorization","text":"<p>For moteus to operate without damage, the XT30 connectors used to transmit power must make a solid connection that is non-intermittent.  As with poor soldering, an intermittent connection can cause inductive spikes, which will destroy components on the controller.</p> <p>When connectors are functional, moderate insertion force should be required and the connectors should not \"wiggle\" much after insertion.</p> <p>The XT30 is not rated for any significant amount of mechanical force when mated.  For any application where cables may flex, strain relief should be used such that no force is applied to the connector.  The connector may be damaged if a system goes \"out of control\" even in one instance, although milder mechanical stress may cause accelerated fatigue and failure.</p> <p>If sparks are observed, that is definitely a problem and the system should be powered off until the connectors can be replaced and mitigations made for what led to that event.</p> <p>Genuine AMASS connectors are rated for 1000 insertions assuming no other mechanical damage, however off-brand connectors may have worse tolerances and may not make a reliable connection for even one insertion.</p>"},{"location":"guides/electrical-setup/#long-daisy-chains","title":"Long daisy chains","text":"<p>When connecting more than 3 moteus controllers or servos in a system on a single power or CAN chain, additional factors should be considered.</p> <ol> <li> <p>It is recommended to use T-spliced power instead of using the daisy chained power connectors for chains greater than 3 units.  Small connector mis-seating or micro-arcing will cause magnified effects with long chains of controllers.</p> </li> <li> <p>CAN bus electrical performance can be a limiting factor.  To operate at the default 5Mbps, you will need to ensure that CAN wires are twisted, all crimps are high quality, and that termination is installed.  Split termination may be required, where two 60 ohm resistors are connected in series with a small filter capacitor connected between the center tap of the resistors and ground.  A 4.7nF capacitor is recommended.  If that is insufficient, BRS can be disabled to operate only at 1Mbps.  With <code>moteus_tool</code> or <code>tview</code>, the <code>--can-disable-brs</code> flag can be used.</p> </li> </ol> <p>mjbots sells a CAN terminator that can be used for this purpose: https://mjbots.com/products/jst-ph3-can-fd-terminator</p>"},{"location":"guides/electrical-setup/#inrush-current-management","title":"Inrush current management","text":"<p>moteus controllers have large DC bulk capacitance with low ESR, this is how they can achieve their small form factor.  As a result, care must be taken when applying power.  If a connector is \"hot-plugged\" extremely large transient currents can develop which may damage the moteus or other components in the system.  These challenges are magnified when more than one moteus controller is attached to the same power bus.</p> <p>Potential solutions:</p> <p>Power Supply: If a wall power supply is used, it can be relied upon to provide a \"soft start\" functionality.  Ensure that all moteus controllers are attached to the power supply before enabling the supply by turning it on or plugging it into a wall.</p> <p>Anti-spark connectors: There exist anti-spark connectors like the XT90-S, which have a power resistor built in which makes contact before main power is applied.  These can be used, but have several drawbacks:</p> <ol> <li>The proper order of connection must always be obeyed.  Unless the XT90-S is connected last, then inrush transients may result.</li> <li>If the power rating on the built-in resistor is not respected, it will silently fail, resulting in no pre-charge protection at all.</li> </ol> <p>Active pre-charge circuits: mjbots sells the mjpower-ss and power_dist, both of which have the primary function of gradually precharging capacitive loads.  Other active pre-charge systems may also be viable.</p>"},{"location":"guides/electrical-setup/#regenerative-braking-safety","title":"Regenerative braking safety","text":"<p>moteus can be commanded to sharply decelerate loads, either directly in response to commands, or due to external disturbances.  When braking a load, moteus by default applies the generated power to the input DC bus.</p> <p>If there is nowhere for this power to go, this can cause problems.  The voltage can increase without bound, which in mild cases will cause the CAN transceiver on all devices connected to the bus to fail, and in severe cases can explode the main FETs or other components on the board.</p> <p>Here's what you should know about the facilities moteus has to deal with this, and what you can do to make your design safer.</p>"},{"location":"guides/electrical-setup/#flux-braking","title":"Flux braking","text":"<p>The feature within moteus itself to deal with this is \"flux braking\".  The flux braking implementation will dissipate extra power in the windings of the motor when the bus voltage gets above a certain threshold.  This is controlled by the <code>servo.flux_brake_margin_voltage</code> and <code>servo.flux_brake_resistance_ohm</code> parameters documented above.</p>"},{"location":"guides/electrical-setup/#design-considerations-for-regenerative-braking","title":"Design considerations for regenerative braking","text":"<p>The following design considerations can be used to minimize the risk of damage to hardware in the event of overvoltage.  These are not a substitute for validation in progressively more demanding situations, but they can help you start off in a good place.</p> <ul> <li> <p>Tightly scope the over-voltage fault / flux braking: The configuration parameter <code>servo.max_voltage</code> can be lowered for all devices on the bus.  This will both cause a fault if the voltage exceeds this value and in conjuction with <code>servo.flux_brake_margin_voltage</code>, select the point at which moteus will attempt to dissipate energy to prevent an overvoltage scenario.  It is recommended to set this to no less than 5V above the maximum expected supply voltage.</p> </li> <li> <p>Power from a battery, not a PSU: When not charged, batteries are capable of sinking current to minimize over-voltage transients.  However, if the battery is fully charged, most battery management systems drastically reduce the allowable charging current.  Thus, a battery is only useful as a mitigation if it is never charged above say 75 or 80% state of charge.</p> </li> <li> <p>Decrease overall system voltage: If you run the moteus controller with say a 10S battery, the peak input voltage can be as high as 42V.  That does not leave very much margin for regenerative loads.  For applications that experience sharp regenerative loads and do not have a battery capable of charging always attached, it is recommended not to exceed 8S (33.6V peak).</p> </li> <li> <p>Use a supply which can sink as well as source: Powering from an inexpensive lab supply is the most dangerous, as they typically have no ability to sink current, only source it.  A \"two quadrant\" supply is the necessary device.</p> </li> </ul>"},{"location":"guides/electrical-setup/#next-steps","title":"Next Steps","text":"<p>After completing electrical connections, proceed to software installation and configuration to begin using your moteus controller.</p>"},{"location":"guides/encoder-overview/","title":"Encoder Overview","text":"<p>This section describes the various ways moteus can be configured to use encoders to sense the rotor, output, or auxiliary devices.  If you intend to only use the onboard on-axis magnetic encoder, you can skip this section.</p>"},{"location":"guides/encoder-overview/#introduction","title":"Introduction","text":"<p>moteus uses encoders to properly control a motor. Encoders provide the feedback needed to know where the motor is and how fast it's moving. Understanding which encoder(s) to use and how to configure them is one of the key decisions you need to make when designing a system, as for many applications encoder selection is the primary determinant of performance parameters like maximum stiffness, control stability and whether homing will be necessary.</p> <p>Moteus uses encoders for two distinct purposes. First, it needs commutation feedback - the electrical relationship between the motor's stator and rotor to apply torque correctly. Second, it needs output feedback - the position and velocity of your output shaft to follow commanded trajectories. A single encoder can serve both purposes, or you can use separate encoders for each.</p> <p>The good news is that moteus comes with an onboard AS5047P or MA600 magnetic encoder that works out of the box for many applications. This encoder mounts on-axis with the motor. For many use cases, especially those without gear reductions, this is all you need. However, if you're using hall sensors, need higher resolution, or have a gear reducer that you want to measure the output of a reducer or other auxiliary devices, you'll want to add other encoders.</p> <p>In this guide, we'll cover a few common variants and leave the rest for the detailed encoder reference.</p>"},{"location":"guides/encoder-overview/#common-configurations","title":"Common Configurations","text":"<p>Here are the most common encoder configurations you'll encounter:</p> <p>Default configuration (onboard encoder only): The AS5047P or MA600 onboard encoder serves as both commutation and output sensor. This works well for many applications, especially those without a reducer installed or with a reducer where either the absolute position of the output is not required or a homing step is permitted.</p> <p>Adding hall sensors: Hall effect sensors provide robust commutation feedback and are useful in high-vibration environments or when cost is a primary concern.  When used as the only encoder, the resulting system will have poor low-velocity and position tracking performance.</p> <p>Dual encoder setups: Using one encoder for commutation (typically the onboard or hall sensors) and a separate high-resolution encoder for output position provides the best performance for precision applications.</p> <p>These two options are described in separate guides below:</p> <ul> <li>Motor with Hall Effects - Adding hall sensors for commutation</li> <li>Dual Encoders - Using separate encoders for commutation and output</li> </ul> <p>Once again, for detailed information about encoder configuration parameters, see the Detailed Encoder Reference.</p>"},{"location":"guides/encoder-overview/#next-steps","title":"Next Steps","text":"<p>Once the encoder has been configured, then you are ready to move on to the motor calibration procedure.</p>"},{"location":"guides/hall-effects/","title":"Motor with Hall Effect Sensors","text":"<p>Many motors include hall effect sensors used to provide commutation information to motor controllers.  moteus is able to use hall effect sensors for both commutation and output positioning.  First, some caveats:</p> <p>They may not be needed: Just because a motor has hall effect sensors built in, does not mean you need to use them.  If you can use the on-axis magnetic encoder integrated into moteus by mounting moteus appropriately relative to the rotor, that will always give better results than using hall effect encoders.</p> <p>You will likely need additional hardware: Most configurations with hall effects will require additional filtering capacitors, placed near moteus, between each signal line and ground.  1nF is a recommended starting point.  They can be added either in the wire harness, or on unpopulated 0402 pads on the moteus-c1, moteus-n1, and moteus-x1.</p> <p>Hall effect sensors used for output positioning have very poor low velocity performance: While hall effect sensors are minimally useful for commutation and higher speed output operation, they will provide poor performance when used as an output encoder at low speeds.  That means many position control applications, which are inherently often at low speed, will give poor results.</p> <p>moteus-r4 cannot easily drive many hall effect sensors: moteus-r4 specifically has only 3.3V supply for external devices, whereas most hall effect encoders require 5V.  Further, the only means of connecting hall effect sensors to moteus-r4 are using unpopulated pads on the back of the board, and not using the onboard encoder.  Other moteus products do not have these specification limitations regarding supply voltage and connectors.</p> <p>If using hall effects for commutation or output positioning is still desired, the below configurations can get you started.</p>"},{"location":"guides/hall-effects/#aux2-configuration","title":"aux2 configuration","text":"<p>This configuration uses hall effect sensors connected to the aux2 GH7 connector for both commutation and output positioning.</p> <p>moteus-c1 (c1 pinout), moteus-n1 (n1 pinout), and moteus-x1 (x1 pinout) all have an aux2 GH7 connector that can provide 5V output and has 5V tolerant IO pins.  The typical wiring diagram looks like the below, although the hall connector is \"nominal\" as there is no real standard:</p> <p></p> <p>As mentioned above, either 1nF capacitors should be installed in the harness between each signal line and ground, or installed on the appropriate unpopulated pads on the board.</p> <p>The following aux2 configuration parameters should be set.</p> <pre><code>aux2.pins.0.mode 6  # hall\naux2.pins.0.pull 1  # pull_up\naux2.pins.1.mode 6  # hall\naux2.pins.1.pull 1  # pull_up\naux2.pins.2.mode 6  # hall\naux2.pins.2.pull 1  # pull_up\naux2.hall.enabled 1\n</code></pre> <p>Then motor_position is configured as follows:</p> <pre><code>motor_position.sources.0.aux_number 2\nmotor_position.sources.0.type 4  # hall\n</code></pre> <p>Finally, when calibrating, the number of poles is required to be specified.</p> <pre><code>python -m moteus.moteus_tool -t 1 --calibrate --cal-motor-poles 30\n</code></pre>"},{"location":"guides/hall-effects/#advanced-dual-encoder-setup","title":"Advanced: Dual Encoder Setup","text":"<p>A more performant configuration may use the hall effect sensors for commutation and a different encoder measuring the output position.  That is not directly described here, but you can look at the Dual Encoders guide as well as the encoder reference to understand how to configure it.</p>"},{"location":"guides/mechanical-setup/","title":"Mechanical Setup","text":"<p>To use the onboard on-axis encoder integrated with moteus, the controller must be mounted with care to ensure proper alignment and ongoing registration.</p>"},{"location":"guides/mechanical-setup/#mechanical-mounting","title":"Mechanical Mounting","text":"<p>If using the default onboard encoder, the following steps must be taken:</p> <ol> <li>A diametrically magnetized sense magnet should be attached to the rotor. The fastening must be rigid, allowing no slip. Adhesive is generally required, cyanoacrylate or epoxy can be used.</li> <li>The moteus controller must be mounted so that the encoder is (a) centered laterally on the sense magnet and (b) has an air-gap of approximately 2mm. This mount must be rigid and allow no slip.</li> </ol> <p>moteus-r4 mounting</p> <p>Unlike other moteus controllers, the moteus-r4 encoder is not centered under the bolt pattern, check the 2D CAD for details.</p> <p>3D printed mounts</p> <p>If using 3D printed mounts, care should be taken to ensure the mount does not warp.  PLA and other low temperature filaments will warp under load at room temperature, and will do so even more when exposed to thermal heating like from a motor controller.  It is recommended to use PETG, PC, or a filament designed to not warp at the operating temperature you intend.</p>"},{"location":"guides/mechanical-setup/#additional-considerations","title":"Additional Considerations","text":"<p>There are additional considerations when mounting, some mostly common sense, and some unique to moteus.</p>"},{"location":"guides/mechanical-setup/#protection-from-debris-and-stray-conductors","title":"Protection from debris and stray conductors","text":"<p>It is advisable to mechanically shield moteus controllers from the environment during operation to prevent contact with stray conductors, dirt, or debris.  Contact with any of these things while the system is energized can result in failure.</p> <p>Similarly, manipulating or working on the system while it is energized should be avoided.</p>"},{"location":"guides/mechanical-setup/#moteus-n1-light-sensitivity","title":"moteus-n1 light sensitivity","text":"<p>moteus-n1 has a voltage regulator which is light sensitive and will fail when exposed to sunlight.  The enclosure used to house the system should be opaque.  If for some reason an enclosure can not be used, opaque expoxy can be placed over the voltage regulator IC.</p> <p>moteus-c1, moteus-r4 and moteus-x1 have no light sensitivity considerations to take into account.</p>"},{"location":"guides/mechanical-setup/#next-steps","title":"Next Steps","text":"<p>Once mechanical mounting is complete, proceed to Electrical Setup to connect the motor phase wires and power.</p>"},{"location":"guides/pid-tuning/","title":"PID Tuning","text":"<p>When operating in position or velocity mode, moteus uses a P(I)D controller to determine what torque to apply at each instant.  The constants that control this operation need to be selected by the user.  Tuning does not have to be challenging, but does require that you understand what you are trying to accomplish.</p>"},{"location":"guides/pid-tuning/#theory","title":"Theory","text":"<p>The purpose of the three gains:</p> <p>Proportional: This term applies a restorative torque that is proportional to the error between the current desired position and the current measured position.  It is measured in Nm per revolution of error as measured at the output of the reducer.  It directly controls the \"stiffness\" of the controller.  If used in isolation, the motor will apply a fixed torque for any given error, i.e. if you manually move the motor 0.1 revolution away from the setpoint, it will apply 0.1 * the torque indefinitely, and then if you move it to be 0.2 revolution away from the setpoint, it will apply 0.2 * the torque.</p> <p>Derivative: This term acts as a \"damping\" term, or viscious resistance.  As an analogy, if the proportional term is the spring in a suspension system, the derivative term is how thick the oil in the suspension is.  The torque applied from this term scales with the magnitude of the error between the desired velocity and the measured velocity.  If all other gains were zero and the motor is disturbed by hand, a larger gain makes it feel like you are working against a thicker fluid resistance.</p> <p>Integrative:  The integrative term applies a torque that scales with the error in position integrated over time.  Many, if not most, moteus systems use no integrative term at all.  Integrative terms are hard to tune, and result in poor transient response.  However, they are the only way to achieve 0 steady state error in a loaded system.  Without an integrative term, the steady state error, while possibly very small, will never be zero.  For the integrative term there are two parameters to select, the gain itself, and the anti-windup gain term.</p>"},{"location":"guides/pid-tuning/#procedure","title":"Procedure","text":"<p>The position control P(I)D loop parameters are set in <code>servo.pid_position</code> and are selected by the user to achieve a desired control response.  Most users want a PID controller that is well damped and sufficiently stiff for their application.</p> <p>Here is a possible procedure for tuning.  It is best executed using tview in a configuration where you can move the motor with your hand.  A load that is close to representative in terms of inertia, damping, and friction is best, but something is better than nothing.</p> <ol> <li>Set kp to be small and kd, ki, and ilimit to be 0. <pre><code>servo.pid_position.kp = 0.001\nservo.pid_position.kd = 0\nservo.pid_position.ki = 0\nservo.pid_position.ilimit = 0\n</code></pre> If you have an understanding of the system, you could select an initial kp that is larger, but you want it to be a value such that the restorative torque is very gradual and you can easily disturb the system by hand.</li> <li>Increase kp by 50% at a time until the desired stiffness is reached.<ol> <li>Test the current value.  A command like <code>d pos nan 0 nan</code> can be used to \"hold position\".  Then use your hand to move the rotor to judge the stiffness.</li> <li>If insufficiently stiff, increase <code>servo.pid_position.kp</code> by 50% and go back to (a)</li> <li>If vibration or instability results, decrease <code>servo.pid_position.kp</code> by 2x and that is roughly a good stable maximum.</li> </ol> </li> <li>Tune the derivative term<ol> <li>Set kd initially to 1/100th of the kp value. For example, the following where FOO is 0.01 * the selected value for <code>servo.pid_position.kp</code>. <code>servo.pid_position.kd = FOO</code></li> <li>Test the current value.  Use <code>d pos nan 0 nan</code> to hold position.  Manually move the motor away from the setpoint, then quickly release it.  If \"damped\" the motor will smoothly come to a stop at the original position.  If underdamped, the motor may oscillate.</li> <li>If insufficiently damped, increase <code>servo.pid_position.kd</code> by 50% and go back to (a)</li> <li>If high frequency vibration or oscillation results, decrease <code>servo.pid_position.kd</code> by 2x and that is roughly a good stable maximum.</li> </ol> </li> <li>If zero steady state error is required, then an integrative term is required.  If not, leave <code>ilimit</code> at 0 and you are done.</li> <li>Configure the integrative term.<ol> <li>Set <code>servo.pid_position.ilimit</code> to be 20% higher than the maximum expected steady state torque.</li> <li>Set an initial value of <code>servo.pid_position.ki</code> equal to the <code>servo.pid_position.kp</code> term.</li> <li>Increase <code>servo.pid_position.ki</code> until the desired response is achieved.  <code>ki</code> will likely need to be numerically much larger than kp, on the order of 10-1000x larger.  A more representative control profile than just a \"hold position\" may be needed to determine if the selected integrative constants are sufficient.</li> </ol> </li> </ol>"},{"location":"guides/pid-tuning/#acceleration-limited-trajectories","title":"Acceleration limited trajectories","text":"<p>Further, it is strongly recommended to configure and use an acceleration limit with moteus that is physically achievable in your system.  Doing so means that the \"desired\" position and \"desired\" velocity will follow continuous, physically achievable trajectories.</p> <ul> <li><code>servo.default_accel_limit</code> can be set in Hz / s.</li> </ul> <p>If you do not set an acceleration limit, or select one that is too high to be physically achievable, your system will experience overshoot during movements and you will find it challenging to tune the P(I)D parameters to achieve a desired response.</p>"},{"location":"guides/pid-tuning/#what-not-to-tune","title":"What not to tune","text":"<p>The \"current loop\" gains are set in <code>servo.pid_dq</code>, and are set during calibration based on the desired torque bandwidth.  They are not normally changed by the user.  Instead, they are selected by specifying an appropriate <code>--cal-bw-hz</code> during calibration.</p>"},{"location":"guides/pid-tuning/#next-steps","title":"Next steps","text":"<p>Now you are ready to control moteus using one of the possible control modes:</p> <ul> <li>Control</li> </ul>"},{"location":"guides/software-installation/","title":"Software Installation","text":"<p>This guide covers installing the software tools needed to communicate with and configure your moteus controller.</p>"},{"location":"guides/software-installation/#installing-moteus_gui","title":"Installing moteus_gui","text":"<p>The moteus_gui package provides essential tools including <code>tview</code> (telemetry viewer) and <code>moteus_tool</code> (configuration utility). Installation varies slightly by platform.</p> LinuxWindowsmacOSRaspberry Pi (cmdline only) <pre><code>python -m pip install moteus-gui\n</code></pre> <p>Note: On Linux, you may need to use either a virtual environment or the <code>--break-system-packages</code> option.</p> <p>fdcanusb udev rules: If using the fdcanusb or mjcanfd-usb-1x adapter, you may need to set up udev rules so regular users can access the device. Follow the instructions at: https://github.com/mjbots/fdcanusb/blob/master/70-fdcanusb.rules</p> <pre><code>python -m pip install moteus-gui\n</code></pre> <p>Note: On some older Windows installations, you need to invoke python as <code>python3</code>, not <code>python</code>.</p> <pre><code>python -m pip install moteus-gui\n</code></pre> <pre><code>python -m venv moteus-venv --system-site-packages\n./moteus-venv/bin/pip install moteus\n</code></pre> <p>Note: For complete Raspberry Pi setup instructions including GUI and hardware configuration, see Raspberry Pi Setup.</p>"},{"location":"guides/software-installation/#running-tview","title":"Running tview","text":"<p>tview is the primary tool for configuring and inspecting the state of your moteus controller. Launch it with:</p> <pre><code>python3 -m moteus_gui.tview\n</code></pre> <p>Alternative: Your pip installation may have added a <code>tview</code> script to your PATH, which you can use instead.</p>"},{"location":"guides/software-installation/#understanding-tview","title":"Understanding tview","text":"<p>tview has three main panes: left, right, and bottom.</p> <p></p>"},{"location":"guides/software-installation/#left-pane-tabs","title":"Left Pane Tabs","text":"<p>The left pane contains two tabs:</p> <p>Right tab (default): Shows a hierarchical tree of all telemetry items currently being reported by the controller.</p> <p>Left tab: Shows a hierarchical tree of all configurable parameters. You can update parameter values by double-clicking on their value and entering a new one.</p>"},{"location":"guides/software-installation/#right-pane","title":"Right Pane","text":"<p>The right pane displays real-time plots of telemetry items. You can populate it with plots by right-clicking on telemetry items in the telemetry tab (left pane, right tab).</p>"},{"location":"guides/software-installation/#bottom-pane","title":"Bottom Pane","text":"<p>The bottom pane contains two tabs:</p> <p>Left tab - console (default): a command line console showing the moteus diagnostic protocol.  It:</p> <ul> <li>Shows commands sent internally by tview and their responses</li> <li>Provides an interactive console to interact with the device using the diagnostic protocol</li> </ul> <p>Right tab - Python: A python REPL that can be used to interact with the the controller(s) using the moteus python library.</p>"},{"location":"guides/software-installation/#next-steps","title":"Next Steps","text":"<p>Now that you have the software installed and understand the tview interface, proceed to the Configuration guide to set up your moteus controller for your specific motor and application.</p>"},{"location":"integration/can-fd/","title":"CAN-FD","text":"<p>The python and C++ libraries are not required to command and monitor moteus, they just make it easier.  Any system capable of generating and receiving CAN-FD frames with the appropriate timing can be used.  Here are some hints to make that easier.</p>"},{"location":"integration/can-fd/#bit-timing-and-basic-communication","title":"Bit timing and basic communication","text":"<p>Moteus requires 1Mbps/5Mbps CAN-FD timing, a sample point of 0.666, and works best if the SJW and DSJW settings are as large as possible.</p> <p>If communication is not working, it is recommended to attach a mjcanfd-usb-1x to the bus at the same time as your host and use it to capture frames.  Any serial application (or <code>cat</code> on Linux) can be used to read the output.  Since they start with the same timings as moteus, you can use that to identify if your frames are being received and being responded to.</p>"},{"location":"integration/can-fd/#decoding-frames-observed-on-the-bus","title":"Decoding frames observed on the bus","text":"<p>There exists a tool in the moteus repository to decode CAN-FD frames sent to or from moteus that can be invaluable in diagnosing what you are sending and why moteus is or is not responding to it.  First, capture a hex formatted dump of the CAN-FD frame in question.  Then:</p> <pre><code>moteus$ ./utils/decode_can_frame.py 1100110F\n11 - READ_REGISTERS - INT8 1 registers\n  00 - Starting at reg 0x000(MODE)\n11 - READ_REGISTERS - INT8 1 registers\n  0f - Starting at reg 0x00f(FAULT)\n</code></pre> <p>and the corresponding response:</p> <pre><code>moteus$ ./utils/decode_can_frame.py 210000210F00\n21 - REPLY - 0 1 registers\n  00 - Starting at reg 0x000(MODE)\n   00 - Reg 0x000(MODE) = 0(STOPPED)\n21 - REPLY - 0 1 registers\n  0f - Starting at reg 0x00f(FAULT)\n   00 - Reg 0x00f(FAULT) = 0\n</code></pre>"},{"location":"integration/can-fd/#generating-appropriate-command-frames","title":"Generating appropriate command frames","text":"<p>The CAN-FD reference and register reference contains the information necessary to generate and parse frames.  However, it can be a lot to digest.  You can use the python library to quickly get example frames that accomplish a given task.  First, create a python script that accomplishes what you want.  Then, in an interactive python REPL:</p> <pre><code>&gt;&gt;&gt; print(c.make_position(position=1, velocity=2, query=True).data.hex())\n01000a0e200000803f0000004011001f01130d\n</code></pre> <p>Where the arguments to <code>make_position</code> correspond to the action you want to accomplish.  You can verify the contents of this frame using <code>decode_can_frame.py</code>:</p> <pre><code>moteus$ ./utils/decode_can_frame.py 01000a0e200000803f0000004011001f01130d\n01 - WRITE_REGISTERS - 0 1 registers\n  00 - Starting at reg 0x000(MODE)\n   0a - Reg 0x000(MODE) = 10(POSITION)\n0e - WRITE_REGISTERS - 3 2 registers\n  20 - Starting at reg 0x020(COMMAND_POSITION)\n   0000803f - Reg 0x020(COMMAND_POSITION) = 1.0\n   00000040 - Reg 0x021(COMMAND_VELOCITY) = 2.0\n11 - READ_REGISTERS - INT8 1 registers\n  00 - Starting at reg 0x000(MODE)\n1f - READ_REGISTERS - F32 3 registers\n  01 - Starting at reg 0x001(POSITION)\n13 - READ_REGISTERS - INT8 3 registers\n  0d - Starting at reg 0x00d(VOLTAGE)\n</code></pre>"},{"location":"integration/cpp/","title":"C++ Client Library","text":"<p>moteus provides a C++ library that can be used to command and control moteus controllers using a supported CAN-FD adapter.</p>"},{"location":"integration/cpp/#integration","title":"Integration","text":"<p>The moteus C++ library is header only, so there are several possible options for integrating the C++ library into your project.</p> <p>Copy the source files: One option is to copy all the relevant headers into your source tree:</p> <ul> <li>https://github.com/mjbots/moteus/tree/main/lib/cpp/mjbots/moteus</li> </ul> <p>CMake: There exists a top level <code>CMakeLists.txt</code> file that can be used with CMake's <code>FetchContent</code> to incorporate the headers into your project.</p> <pre><code>include(FetchContent)\nFetchContent_Declare(\n  moteus\n  GIT_REPOSITORY https://github.com/mjbots/moteus.git\n  GIT_TAG        f14f789fefeae9caf185b950cf4e32df01d022ea\n)\n\nFetchContent_MakeAvailable(moteus)\n\nadd_executable(myproject myproject.cc)\ntarget_link_libraries(myproject moteus::cpp)\n</code></pre> <p>bazel: moteus does export bazel <code>BUILD</code> files and can be integrated into bazel projects using that mechanism as well.</p>"},{"location":"integration/cpp/#usage","title":"Usage","text":"<p>Basic usage is similar, although slightly different to the python library.  A minimal example follows:</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;unistd.h&gt;\n#include \"moteus.h\"\n\nnamespace moteus = mjbots::moteus;\n\nint main(int argc, char** argv) {\n  moteus::Controller::DefaultArgProcess(argc, argv);\n\n  moteus::Controller c([]() {\n    moteus::Controller::Options options;\n    options.id = 1;\n    return options;\n  }());\n\n  moteus::PositionMode::Command command;\n  command.position = std::numeric_limits&lt;double&gt;::quiet_NaN();\n\n  while (true) {\n    const auto maybe_result = c.SetPosition(command);\n    if (maybe_result) {\n      const auto&amp; v = maybe_result-&gt;values;\n      std::cout &lt;&lt; \"Mode: \" &lt;&lt; v.mode\n                &lt;&lt; \" Fault: \" &lt;&lt; v.fault\n                &lt;&lt; \"Position: \" &lt;&lt; v.position\n                &lt;&lt; \" Velocity: \" &lt;&lt; v.velocity\n                &lt;&lt; \"\\n\";\n    }\n    ::usleep(10000);\n  }\n  return 0;\n}\n</code></pre>"},{"location":"integration/cpp/#specifying-alternate-query-registers","title":"Specifying alternate query registers","text":"<p>By default, only a subset of registers are queried by the library.</p>"},{"location":"integration/cpp/#common-register-selection","title":"Common register selection","text":"<p>To select other common options you can either (a) change the default query resolution or (b) pass an \"override\" query resolution.</p>"},{"location":"integration/cpp/#option-a-change-the-default","title":"Option (a): Change the default","text":"<pre><code>moteus::Controller c([]() {\n  moteus::Controller::Options options;\n  options.query_format.power = moteus::kFloat;\n  return options;\n}());\n</code></pre>"},{"location":"integration/cpp/#option-b-specify-an-override","title":"Option (b): Specify an \"override\"","text":"<pre><code>moteus::Controller c;\nmoteus::PositionMode::Command command;\nmoteus::Query::Formay query_override;\n\nquery_override.power = moteus::kFloat;\nc.SetPosition(command, nullptr, &amp;query_override);\n</code></pre>"},{"location":"integration/cpp/#less-common-register-selection","title":"Less common register selection","text":"<p>For registers which do not have predefined fields in <code>Query::Format</code>, you can use the <code>extra</code> mechanism through either the constructor options or override argument.</p> <pre><code>moteus::Controller c([]() {\n  moteus::Controller::Options options;\n\n  options.query_format.extra[0].register_number = moteus::Register::kAux1AnalogIn1;\n  options.query_format.extra[0].resolution = moteus::kFloat;\n\n  return options;\n}());\n</code></pre>"},{"location":"integration/cpp/#specifying-alternate-command-registers","title":"Specifying alternate command registers","text":"<p>As with queries, by default, only a subset of registers are sent with <code>SetPosition</code> or <code>MakePosition</code> commands.  Without additional work, only \"position\" and \"velocity\" are sent.  To select others, they can either be changed through (a) the defaults or by (b) overriding them.</p>"},{"location":"integration/cpp/#option-a-change-the-default_1","title":"Option (a): Change the default","text":"<pre><code>moteus::Controller c([]() {\n  moteus::Controller::Options options;\n  options.position_format.feedforward_torque = moteus::kFloat;\n  return options;\n}());\n\nmoteus::PositionMode::Command command;\ncommand.position = std::numeric_limits&lt;double&gt;::quiet_NaN();\ncommand.velocity = 0.0;\ncommand.feedforward_torque = 0.1;\n\nc.SetPosition(command);\n</code></pre>"},{"location":"integration/cpp/#option-b-specify-an-override_1","title":"Option (b): Specify an \"override\"","text":"<pre><code>moteus::Controller c;\n\nmoteus::PositionMode::Command command;\ncommand.position = std::numeric_limits&lt;double&gt;::quiet_NaN();\ncommand.velocity = 0.0;\ncommand.feedforward_torque = 0.1;\n\nmoteus::PositionMode::Format format;\nformat.feedforward_torque = moteus::kFloat;\n\nc.SetPosition(command, &amp;format);\n</code></pre>"},{"location":"integration/cpp/#alternate-usage-modes","title":"Alternate Usage Modes","text":"<p>Like the python library, the C++ library has two modes of operation.  One designed for ease of use, and the other for maximizing bus utilization and command rate.  The former are the <code>Set*</code> variant methods used above.  Like python, there exist <code>Make*</code> variant methods which generate a frame, but do not send it.  Those can be used with a manually constructed transport.</p> <pre><code>auto transport = moteus::MakeSingletonTransport();\n\nmoteus::Controller c([&amp;]() {\n  moteus::Controller::Options options;\n  options.transport = transport;\n  return options;\n}());\n\nstd::vector&lt;moteus::CanFdFrame&gt; commands_to_send;\nstd::vector&lt;moteus::CanFdFrame&gt; replies_to_receive;\n\nmoteus::PositionMode::Command command;\ncommands_to_send.push_back(c.MakePosition(command));\n\ntransport-&gt;BlockingCycle(\n  commands_to_send.data(),\n  commands_to_send.size(),\n  &amp;replies_to_receive);\n</code></pre>"},{"location":"integration/python/","title":"Python Client Library","text":"<p>moteus provides a python library that can be used to command and control moteus controllers using a supported CAN-FD adapter.</p>"},{"location":"integration/python/#installation","title":"Installation","text":"<p>To install, just use:</p> <pre><code>pip install moteus\n</code></pre> <p>Or add to your <code>requirements.txt</code> file, or via whatever mechanism your project uses.</p>"},{"location":"integration/python/#basic-usage","title":"Basic Usage","text":"<p>There are two basic approaches to using the python library.  The first is the easiest, although does not provide optimal bus utilization if that is a design requirement.</p> <p>First, construct one or more controller instances:</p> <pre><code>import asyncio\nimport moteus\n\nasync def main():\n    c1 = moteus.Controller(id=1)\n    c2 = moteus.Controller(id=2)\n    # ...\n\nif __name__ == '__main__':\n    asyncio.run(main())\n</code></pre> <p>Then, at regular intervals, send commands to each of the devices using the <code>set_</code> variant of each API.</p> <pre><code>while True:\n  c1_result = await c1.set_position(\n      position=math.nan, velocity=1.0, accel_limit=0.5, query=True)\n  c2_result = await c2.set_position(\n      position=math.nan, velocity=0.5, accel_limit=0.25, query=True)\n\n  c1_position = c1_result.values[moteus.Register.POSITION]\n  c2_position = c2_result.values[moteus.Register.POSITION]\n\n  print(c1_position, c2_position)\n\n  await asyncio.sleep(0.01)\n</code></pre>"},{"location":"integration/python/#cycle-based-usage","title":"<code>.cycle</code> based usage","text":"<p>If bus utilization or a high update rate is desired, an alternate API can be used to maximize performance.  In this API, the commands are constructed in advance using <code>make_</code> variants of commands, then submitted to the library in a group.</p> <pre><code>import argparse\nimport asyncio\nimport moteus\n\nasync def main():\n    parser = argparse.ArgumentParser()\n    moteus.make_transport_args(parser)\n    args = parser.parse_args()\n\n    transport = moteus.get_singleton_transport(args)\n    c1 = moteus.Controller(id=1, transport=transport)\n    c2 = moteus.Controller(id=2, transport=transport)\n    # ...\n\n    while True:\n        results = await transport.cycle([\n           c1.make_position(position=math.nan, query=True)\n           c2.make_position(position=math.nan, query=True),\n           ])\n\n        # Print the ID and position of all received responses.\n        print(\", \".join(\n            f\"{x.source} \" +\n            f\"{x.values[moteus.Register.POSITION]}\"\n            for x in results))\n\n        await asyncio.sleep(0.01)\n\nif __name__ == '__main__':\n    asyncio.run(main())\n</code></pre>"},{"location":"integration/python/#querying-alternate-registers","title":"Querying alternate registers","text":"<p>By default, only a limited set of registers are queried.  The full set of available registers can be found in the register reference documentation.  The easiest way to query additional registers is to pass an alternate <code>QueryResolution</code> structure to the <code>Controller</code> constructor.</p> <pre><code>qr = moteus.QueryResolution()\nqr.power = moteus.F32\nc = moteus.Controller(id=1, query_resolution=qr)\n</code></pre> <p>If the register you want is not available in the <code>QueryResolution</code> structure, it can be requested using the <code>_extra</code> method:</p> <pre><code>qr = moteus.QueryResolution()\nqr._extra = {\n    moteus.Register.ENCODER_1_POSITION: moteus.F32,\n    moteus.Register.ENCODER_1_VELOCITY: moteus.F32,\n}\nc = moteus.Controller(id=1, query_resolution=qr)\n</code></pre>"},{"location":"integration/python/#api-reference","title":"API Reference","text":"<ul> <li>Python API Reference</li> </ul>"},{"location":"integration/python/#related-sections","title":"Related Sections","text":"<ul> <li>Control Modes - Understanding different control strategies</li> <li>Configuration Parameters - Available parameters</li> <li>Raspberry Pi Setup - Platform-specific configuration</li> </ul>"},{"location":"platforms/arduino/","title":"Arduino","text":"<p>moteus provides a simplified version of the C++ library for use with Arduino compatible microcontroller systems.</p>"},{"location":"platforms/arduino/#installation","title":"Installation","text":"<p>Open the Arduino library manager, search for \"moteus\" and install.  Then open one of the examples and modify it.  \"WaitComplete\" is a good one to get started with.</p>"},{"location":"platforms/arduino/#supported-hardware","title":"Supported hardware","text":"<p>Microcontroller: Nearly any board compatible with the Arduino software is supported</p> <p>CAN-FD: The library only supports CAN-FD controllers and transceivers compatible with the acan2517FD library.</p> <p>There are two pieces of configuration that are board and controller specific.</p>"},{"location":"platforms/arduino/#pin-assignments","title":"Pin Assignments","text":"<p>The <code>ACAN2517FD</code> constructor requires that it be passed the correct pins that are used for the SPI peripheral connected to the MCP2517FD controller.  For an external controller, you can use the pins you have physically wired to the controller.  For an integrated MCP2517FD you will need to look at your board documentation.</p> <pre><code>#define MCP2517_CS  17\n#define MCP2517_INT 7\n// For the Longan CANBed FD, the \"SPI\" peripheral determines which\n// pins are used.\nACAN2517FD can(MCP2517_CS, SPI, MCP2517_INT);\n</code></pre>"},{"location":"platforms/arduino/#can-fd-timing","title":"CAN-FD Timing","text":"<p>You need to match the CAN-FD base clock rate that your adapter uses.  Different adapters have different base clock rates.</p> <p>Longan Labs CANBed FD: This board uses a 20MHz clock</p> <p>Mikro MCP2517FD Click: This board defaults to a 40MHz clock, but can be configured by jumper.</p> <p>Regardless, you need to pass the correct clock rate using the <code>ACAN2517FDSettings</code> object.</p> <pre><code>ACAN2517FDSettings settings(\n    ACAN2517FDSettings::OSC_20MHz,\n    1000ll * 1000ll,\n    DataBitRateFactor::x1);\n\nsettings.mArbitrationSJW = 2;\nsettings.mDriverTransmitFIFOSize = 1;\nsettings.mDriverReceiveFIFOSize = 2;\n\nconst uint32_t errorCode = can.begin(settings, [] { can.isr(); });\n</code></pre>"},{"location":"platforms/arduino/#caveats","title":"Caveats","text":"<p>There are some caveats when controlling moteus from a microcontroller.</p>"},{"location":"platforms/arduino/#can-fd-adapter-still-required","title":"CAN-FD adapter still required","text":"<p>While you can command and control moteus from the Arduino library, there is currently no mechanism to calibrate a new motor with a controller.  Thus you must have a CAN-FD adapter that is able to be connected to a computer with an operating system in order to run the calibration process and it is also much easier to use one to set the configuration and tune the PID gains.</p>"},{"location":"platforms/arduino/#teensy-4-integrated-can-fd-controller-is-not-supported","title":"Teensy 4 integrated CAN-FD controller is not supported","text":"<p>There exists an unsupported PR to handle this, but at the moment, the CAN-FD controller integrated into Teensy 4 microcontrollers is not supported by the Arduino library.  External MCP2517FD controllers work just fine with any Teensy controller.</p>"},{"location":"platforms/arduino/#termination","title":"Termination","text":"<p>Many external MCP2517FD controller/transceivers do not have termination resistors.  To operate correctly, a CAN-FD bus is intended to have 2 120ohm resistors between CANL and CANH, one at each end of the bus.  Often short busses will work acceptly with only 1 termination resistor, but never with 0.</p>"},{"location":"platforms/arduino/#flash-and-storage-limitations","title":"Flash and storage limitations","text":"<p>With some smaller Arduino platforms, notably the Arduino Uno or Longan Labs CANBed FD, the combination of the ACAN2517FD library and the moteus library can consume a significant fraction of the flash and RAM available.\u2002For simple applications this isn\u2019t a problem, but if you want to execute something more complex, you may be better served using a more capable Arduino compatible processor, like a Teensy 4 or a Nano Sense 33.</p>"},{"location":"platforms/arduino/#overview-video","title":"Overview video","text":"<p>A video overview of the process of using an Arduino with moteus can be found here:</p>"},{"location":"platforms/jetson/","title":"Nvidia Jetson Setup","text":"<p>Many (maybe all) NVIDIA Jetson boards include an onboard CAN-FD controller.  However, very few NVIDIA Jetson carrier boards include a CAN-FD transceiver.  The former manages the logic level CAN-FD protocol, the latter translates to the electrical wire interface and both are required.</p> <p>There are three major options for communicating with moteus controllers from an NVIDIA Jetson board:</p> <ol> <li> <p>USB Adapter: A mjcanfd-usb-1x or similar USB adapter can be used.  This is simple and relatively convenient, although is bulky and can be unreliable in systems that experience physical vibration or EMI.</p> </li> <li> <p>PCIe/m.2 Adapter: Many Jetson boards have an accessible m.2 slot.  These can be used with adapters like the PEAK m.2 CAN-FD adapter.  Do note that some Jetson carrier boards have an m.2 adapter, but it is physically mounted in such a way that precludes using the PEAK adapter specifically because mechanical interference would result.</p> </li> <li> <p>Onboard Jetson Controller: To use this, you either need a carrier board with a CAN-FD transceiver, or you must connect an external transceiver to the appropriate pins.</p> </li> </ol> <p>For option 2 or 3, you then configure the CAN-FD interface using the same method as for any socketcan device.  That reference is here:</p> <ul> <li>socketcan Configuration</li> </ul>"},{"location":"platforms/raspberry-pi/","title":"Raspberry Pi Installation","text":"<p>The non-gui moteus library will work on a Raspberry Pi out of the box:</p> <pre><code>python -m venv --system-site-packages moteus-venv\nsource moteus-venv/bin/activate\npip install moteus\n</code></pre> <p>However, neither pypi nor piwheels has a functioning pyside2 library, which is needed for <code>moteus_gui</code>, and thus tview.  Fortunately, it is packaged in Raspberry Pi OS.  To use that version, you can do the following:</p> <pre><code>sudo apt install python3-pyside2* python3-serial python3-can python3-matplotlib python3-qtconsole\n\nsource moteus-venv/bin/activate\npip install asyncqt importlib_metadata pyelftools\npip install --no-deps moteus moteus_gui\n</code></pre>"},{"location":"platforms/raspberry-pi/#running-moteus_tool-and-tview","title":"Running moteus_tool and tview","text":"<p>pi3hat specific options for these tools are documented at https://github.com/mjbots/pi3hat/blob/master/docs/reference.md#usage-with-client-side-tools</p> <p>Note that to use the pi3hat, all python scripts must be run as root. Using sudo is one mechanism to do so:</p> <pre><code>source moteus-venv/bin/activate\npip install moteus-pi3hat\n\nsudo moteus-venv/bin/tview\n</code></pre>"},{"location":"platforms/socketcan/","title":"socketcan","text":"<p>Many CAN-FD adapters can be used with the Linux socketcan subsystem.  This section describes how to configure them for use with moteus:</p>"},{"location":"platforms/socketcan/#bit-timings","title":"Bit Timings","text":"<p>To communicate with moteus, both the bitrate AND sample point AND sjw/dsjw must be configured for the socketcan device.  The following command will work with most devices:</p> <pre><code>ip link set can0 up type can \\\n  bitrate 1000000 dbitrate 5000000 \\\n  sjw 10 dsjw 5 \\\n  sample-point 0.666 dsample-point 0.666 \\\n  restart-ms 1000 fd on\n</code></pre> <p>Some devices will give an error if the <code>sjw</code> or <code>dsjw</code> options are too large.  In that case, select the largest possible <code>sjw</code> or <code>dsjw</code> option.</p>"},{"location":"platforms/socketcan/#incompatible-adapters","title":"Incompatible adapters","text":"<p>CAN-FD adapters that use the slcan protocol, or that are derived from canable hardware whether or not they use the slcan or candlelight firmware, are known to be currently incompatible with moteus controllers.</p>"},{"location":"protocol/can/","title":"CAN Protocol","text":"<p>The register command set is intended for use in real-time applications.  It provides multiple levels of conciseness, and is possible to operate at over 1kHz on the provided FD-CAN communications bus.</p> <p>Common definitions:</p> <ul> <li>endian-ness: All primitive types are in least significant byte   first</li> <li>varuint: A sequence of one or more uint8 values, in least   significant byte first order.  For each value, the 7 LSBs contain   data and if the MSB is set, it means there are more bytes remaining.   At most, it may represent a single uint32 and thus 5 bytes is the   maximum valid length.</li> <li>float: An IEEE 754 32-bit floating point number.</li> </ul>"},{"location":"protocol/can/#can-format","title":"CAN Format","text":"<p>Communication with moteus is conducted via CAN-FD frames with a 1Mbit standard bitrate and a 5Mbit data bitrate.</p>"},{"location":"protocol/can/#can-id","title":"CAN ID","text":"<p>The ID is structured as a 16 bit number, with the high 8 bits being the \"source\" and the low 8 bits being the \"destination\".  The destination is the 7 bit servo ID with 0 as the highest bit.  The source is an arbitrary 7 bit number, with the high bit being 1 if moteus should reply to the message.</p> <p>The CAN frame must be an extended one if the ID would be greater than 0x7fff, but otherwise whether or not a frame is extended is not considered.</p> <p>Example:</p> <p>ID: 0x8001  * Send from source 0  * To destination 1  * 16th bit is set, so a reply is requested</p> <p>ID: 0x100  * Send from source 1  * To destination 0  * No reply is requested</p>"},{"location":"protocol/can/#subframes","title":"Subframes","text":"<p>Each CAN-FD frame contains one or more \"subframes\".  A short description of the allowable subframe types are described below.  The canonical reference is located at multiplex/format.h</p> <p>Any extra trailing padding bytes required in the CAN-FD frame should be set to NOP (0x50).</p>"},{"location":"protocol/can/#write-registers","title":"Write Registers","text":"<p>0x00, 0x04, 0x08, 0x0c - write (int8|int16|int32|float)</p> <ul> <li><code>varuint</code> =&gt; number of registers (may be optionally encoded as a   non-zero 2 LSBS of the subframe type)</li> <li><code>varuint</code> =&gt; start register number</li> <li>N x (int8|int16|int32|float) =&gt; values</li> </ul>"},{"location":"protocol/can/#read-registers","title":"Read Registers","text":"<p>0x10, 0x14, 0x18, 0x1c - read (int8|int16|int32|float)</p> <ul> <li><code>varuint</code> =&gt; number of registers (may be optionally encoded as a non-zero 2 LSBs)</li> <li><code>varuint</code> =&gt; start register number</li> </ul>"},{"location":"protocol/can/#reply","title":"Reply","text":"<p>0x20, 0x24, 0x28, 0x2c - reply (int8|int16|int32|float)</p> <ul> <li><code>varuint</code> =&gt; number of registers (may be optionally encoded as a non-zero 2 LSBs)</li> <li><code>varuint</code> =&gt; start register number</li> <li>N x (int8|int16|int32|float) =&gt; values</li> </ul>"},{"location":"protocol/can/#errors","title":"Errors","text":"<p>0x30, 0x31 - write/read error</p> <ul> <li><code>varuint</code> =&gt; register number</li> <li><code>varuint</code> =&gt; error number</li> </ul>"},{"location":"protocol/can/#nop","title":"NOP","text":"<p>0x50 - no operation</p>"},{"location":"protocol/can/#example","title":"Example","text":"<p>A single CAN-FD frame can be used to command the servo, and initiate a query of certain registers.  An example frame might look like the following, encoded in hex with annotations.</p> <ul> <li><code>01</code> - write a single int8 register (number of registers is encoded   in the 2 LSBs)</li> <li><code>00</code> - start register number \"Mode\"</li> <li><code>0a</code> - \"position\" mode</li> <li><code>07</code> - write 3x int16 registers (number of registers is encoded in   the 2 LSBs)</li> <li><code>20</code> - register 0x020</li> <li><code>6000</code> - position = 0x0060 = 96 = 3.456 degrees</li> <li><code>2001</code> - velocity = 0x0120 = 288 = 25.92 dps</li> <li><code>50ff</code> - feedforward torque = 0xff50 = -176 = 1.76 N*m</li> <li><code>14</code> - read int16 registers</li> <li><code>04</code> - read 4 registers</li> <li><code>00</code> - starting at 0x000 (so 0x000 Mode, 0x001 Position, 0x002    Velocity, 0x003 Torque)</li> <li><code>13</code> - read 3x int8 registers</li> <li><code>0d</code> - starting at 0x00d (so 0x00d Voltage, 0x00e Temperature,     0x00f Fault code)</li> </ul> <p>Thus the whole CAN-FD message would be (in hex):</p> <p><code>01000a07206000200150ff140400130d</code></p> <p>To send this using the fdcanusb converter to a device configured at the default address of 1, you could write.</p> <p><code>can send 8001 01000a07206000200150ff140400130d</code></p> <p>The <code>80</code> in ID is used for two purposes.  The high bit being set forces the device to respond (otherwise it will not respond, even if query commands are sent).  The remaining bits are the \"ID\" to respond to.  In response to this command, a possible response from the servo would look like:</p> <p><code>rcv 100 2404000a005000000170ff230d181400</code></p> <p>Decoded, that means:</p> <ul> <li> <p><code>100</code> from device \"1\" to device \"0\"</p> </li> <li> <p><code>24</code> reply with int16 values</p> </li> <li><code>04</code> 4 registers</li> <li><code>00</code> starting at register 0</li> <li><code>0a00</code> in mode 10 - Position</li> <li><code>5000</code> position is 0x0050 = 80 = 2.88 degrees</li> <li><code>0001</code> velocity is 0x0100 = 256 = 23.04 dps</li> <li><code>70ff</code> torque is 0xff70 = -144 = -1.44 Nm</li> <li><code>23</code> reply with 3 int8 values</li> <li><code>0d</code> starting at register 0x00d</li> <li><code>18</code> voltage is 12V</li> <li><code>14</code> temperature is 20C</li> <li><code>00</code> no fault</li> </ul>"},{"location":"protocol/diagnostic/","title":"Diagnostic Protocol","text":"<p>The following command set is intended for debugging and diagnostics. It can be entered from <code>tview</code> or the <code>--console</code> mode of <code>multiplex_tool</code> or <code>moteus_tool</code>.</p>"},{"location":"protocol/diagnostic/#d-board-debug","title":"<code>d</code> - board debug","text":""},{"location":"protocol/diagnostic/#d-stop","title":"<code>d stop</code>","text":"<p>This causes the controller to enter the \"stopped\" state, which disables the motor driver.</p>"},{"location":"protocol/diagnostic/#d-raw","title":"<code>d raw</code>","text":"<p>This enters the \"raw\" PWM mode.  Syntax:</p> <pre><code>d raw &lt;pwm_a&gt; &lt;pwm_b&gt; &lt;pwm_c&gt;\n</code></pre> <p>Where the pwm values are between 0.0 and 1.0.  A command to the idle state is thus: <code>d raw 0.5 0.5 0.5</code>.</p>"},{"location":"protocol/diagnostic/#d-pwm","title":"<code>d pwm</code>","text":"<p>This enters voltage-FOC mode.  Syntax:</p> <pre><code>d pwm &lt;phase&gt; &lt;magnitude&gt; [&lt;phase_rate&gt;]\n</code></pre> <p>Where phase is in radians, magnitude is in volts, and the optional phase rate is in radians per second.</p>"},{"location":"protocol/diagnostic/#d-dq","title":"<code>d dq</code>","text":"<p>This enters the current controlled FOC mode.  Syntax:</p> <pre><code>d dq &lt;d_A&gt; &lt;q_A&gt;\n</code></pre>"},{"location":"protocol/diagnostic/#d-pos","title":"<code>d pos</code>","text":"<p>This enters the position control FOC mode.  Syntax:</p> <pre><code>d pos &lt;pos&gt; &lt;vel&gt; &lt;max_torque&gt; [options...]\n</code></pre> <p>Each optional element consists of a prefix character followed by a value.  Permissible options are:</p> <ul> <li><code>p</code> - kp scale: the configured kp value is multiplied by this   constant for the duration of this command</li> <li><code>d</code> - kd scale: the configured kd value is multiplied by this   constant for the duration of this command</li> <li><code>i</code> - ki ilimit scale: the configured ilimit value is multiplied by   this constant for the duration of this command</li> <li><code>s</code> - stop position: when a non-zero velocity is given, motion stops   when the control position reaches this value.</li> <li><code>f</code> - feedforward torque in Nm</li> <li><code>t</code> - timeout: If another command is not received in this many   seconds, enter the timeout mode.</li> <li><code>v</code> - velocity limit: the given value will override the global   velocity limit for the duration of this command.</li> <li><code>a</code> - acceleration limit: the given value will override the global   acceleration limit for the duration of this command.</li> <li><code>o</code> - fixed voltage override: while in affect, treat the control as   if <code>fixed_voltage_mode</code> were enabled with the given voltage</li> <li><code>c</code> - fixed current override: while in affect, treat the control   like <code>fixed_voltage_mode</code>, but instead commanding a fixed current.</li> <li><code>b</code> - if non-zero, then ignore all <code>servopos</code> position bounds</li> </ul> <p>The position, velocity, maximum torque, and all optional fields have the same semantics as for the register protocol documented above.</p>"},{"location":"protocol/diagnostic/#d-tmt","title":"<code>d tmt</code>","text":"<p>Enter the timeout mode.  This mode commands a zero velocity and can only be exited through the stopped state.</p> <pre><code>d tmt &lt;pos&gt; &lt;vel&gt; &lt;max_torque&gt; [options...]\n</code></pre> <p>Available options are identical to <code>d pos</code>.</p>"},{"location":"protocol/diagnostic/#d-zero","title":"<code>d zero</code>","text":"<p>Enter the zero velocity state.  A zero velocity is commanded regardless of position.</p> <pre><code>d zero &lt;pos&gt; &lt;vel&gt; &lt;max_torque&gt; [options...]\n</code></pre> <p>Available options are identical to <code>d pos</code>.  <code>pos</code> and <code>vel</code> are ignored.</p>"},{"location":"protocol/diagnostic/#d-within","title":"<code>d within</code>","text":"<p>Enter the \"stay within\" state.  When the position is contained within the given bounds, only the feedforward torque is applied.  Otherwise, the position mode controller is used to hold the position at the violated boundary.</p> <pre><code>d within &lt;lowbound&gt; &lt;highbound&gt; &lt;max_torque&gt; [options...]\n</code></pre> <p>The fields have the same semantics as for the register protocol documented above.  The options are largely the same as for <code>d pos</code>. Unsupported options include:</p> <ul> <li><code>s</code> - stop position</li> <li><code>o</code> - fixed voltage override</li> <li><code>c</code> - fixed current override</li> </ul>"},{"location":"protocol/diagnostic/#d-brake","title":"<code>d brake</code>","text":"<p>Enter the \"brake\" state.  In this mode, all motor phases are shorted to ground, resulting in a passive \"braking\" action.</p>"},{"location":"protocol/diagnostic/#d-nearest","title":"<code>d nearest</code>","text":"<p>Update the current position to the closest one which is consistent with a given output position.</p> <pre><code>d rezero &lt;position&gt;\n</code></pre>"},{"location":"protocol/diagnostic/#d-exact","title":"<code>d exact</code>","text":"<p>Update the current position to exactly the given value.</p> <pre><code>d exact &lt;position&gt;\n</code></pre>"},{"location":"protocol/diagnostic/#d-req-reindex","title":"<code>d req-reindex</code>","text":"<p>Reset the homing state to relative based, requiring any homing procedure to be re-run.</p> <pre><code>d req-reindex\n</code></pre>"},{"location":"protocol/diagnostic/#d-recapture","title":"<code>d recapture</code>","text":"<p>When in position mode, reset the control position and velocity to the currently sensed values.</p> <pre><code>d recapture\n</code></pre>"},{"location":"protocol/diagnostic/#d-cfg-set-output","title":"<code>d cfg-set-output</code>","text":"<p>Modify the configuration as required so that the current observed position will be equal to the given value.  Note, the configuration is not written to persistent storage.</p> <pre><code>d cfg-set-output &lt;position&gt;\n</code></pre>"},{"location":"protocol/diagnostic/#d-cal","title":"<code>d cal</code>","text":"<p>INTERNAL moteus_tool USE ONLY: Enter the encoder calibration mode. Upon starting this command, the controller will spin the motor in voltage-FOC mode until the encoder covers a full revolution, then repeat the process in the other direction.  During the process, the current commanded phase and encoder value are periodically emitted to the console.</p> <p>Syntax:</p> <pre><code>d cal &lt;magnitude&gt; [options...]\n</code></pre> <p>Each optional element consists of a prefix character followed by a value.  Permissible options are:</p> <ul> <li><code>s</code> - calibration speed in electrical revolutions per second</li> </ul> <p>NOTE: This command is for internal moteus_tool use only.  It performs only part of the calibration process, and saves nothing to the persistent storage.</p>"},{"location":"protocol/diagnostic/#d-flash","title":"<code>d flash</code>","text":"<p>Enter the bootloader.</p> <p>NOTE: This is only intended for internal use.  Users who want to flash new firmware should use <code>moteus_tool</code>.</p>"},{"location":"protocol/diagnostic/#aux12-aux-port-manipulation","title":"<code>aux[12]</code> - Aux port manipulation","text":"<p>All commands are supported on both <code>aux1</code> and <code>aux2</code>.</p>"},{"location":"protocol/diagnostic/#aux1-out-set-gpio-output-values","title":"<code>aux1 out</code> - Set GPIO Output Values","text":"<pre><code>aux1 out &lt;data&gt;\n</code></pre> <p>'data' is a single decimal integer.  Only bits associated with pins configured as digital outputs are used, the remainder are ignored.</p>"},{"location":"protocol/diagnostic/#aux1-pwm-set-pwm-output-values","title":"<code>aux1 pwm</code> - Set PWM Output Values","text":"<pre><code>aux1 pwm &lt;pin&gt; &lt;value&gt;\n</code></pre> <p>'pin' is a number from 0 to 4 that gives the pin to set.</p> <p>'value' is a floating point value between 0.0 and 1.0 that gives the output duty cycle for the pin.</p>"},{"location":"protocol/diagnostic/#aux1-ic-cmd-initiate-an-ic-pz-command","title":"<code>aux1 ic-cmd</code> - Initiate an iC-PZ command","text":"<pre><code>aux1 ic-cmd &lt;HEXBYTE&gt;\n</code></pre> <p>An example of entering analog mode calibration.</p> <pre><code>aux1 ic-cmd B0\n</code></pre>"},{"location":"protocol/diagnostic/#aux1-ic-wr-write-ic-pz-register","title":"<code>aux1 ic-wr</code> - Write iC-PZ register","text":"<pre><code>aux1 ic-wr &lt;reg&gt; &lt;data&gt;\n</code></pre> <p>Register is one byte in hex, data is 1 or more bytes in hex.</p> <p>Example of switching to memory page 0.</p> <pre><code>aux1 ic-wr 40 00\n</code></pre>"},{"location":"protocol/diagnostic/#aux1-ic-rd-read-ic-pz-register","title":"<code>aux1 ic-rd</code> - Read iC-PZ register","text":"<pre><code>aux1 ic-rd &lt;reg&gt; &lt;length&gt;\n</code></pre> <p>The register is one byte in hex, length is a decimal value indicating the number of bytes to read.</p> <p>Example of reading the temperature data:</p> <pre><code>aux1 ic-rd 4e 2\n</code></pre>"},{"location":"protocol/diagnostic/#aux1-ic-extra-select-alternate-periodic-data","title":"<code>aux1 ic-extra</code> - Select alternate periodic data","text":"<pre><code>aux1 ic-extra &lt;fields&gt;\n</code></pre> <p>\"fields\" is a decimal bitmask of items to read at 1000Hz and display in the diagnostic stream.</p> <p>bit 0 - the diagnosis command result bit 1 - the contents of the AI_PHASES registers</p> <p>Example of enabling the AI_PHASES registers only:</p> <pre><code>aux1 ic-extra 2\n</code></pre>"},{"location":"protocol/diagnostic/#tel-telemetry","title":"<code>tel</code> - telemetry","text":""},{"location":"protocol/diagnostic/#tel-get","title":"<code>tel get</code>","text":"<p>Retrieve the contents of a given channel.  Text or binary mode is determined via the <code>tel fmt</code> or <code>tel text</code> commands, and defaults to binary mode.</p> <pre><code>tel get &lt;channel&gt;\n</code></pre>"},{"location":"protocol/diagnostic/#tel-list","title":"<code>tel list</code>","text":"<p>List all available telemetry channels.</p>"},{"location":"protocol/diagnostic/#tel-schema","title":"<code>tel schema</code>","text":"<p>Report the binary schema associated with the given channel.</p> <pre><code>tel schema &lt;channel&gt;\n</code></pre> <p>The schema is reported as follows:</p> <pre><code>emit &lt;channel&gt;\\r\\n\n&lt;LE uint32 size&gt;&lt;data&gt;\n</code></pre>"},{"location":"protocol/diagnostic/#tel-rate","title":"<code>tel rate</code>","text":"<p>Control the rate at which a given channel is emitted.</p> <pre><code>tel rate &lt;channel&gt; &lt;rate_ms&gt;\n</code></pre>"},{"location":"protocol/diagnostic/#tel-fmt","title":"<code>tel fmt</code>","text":"<p>Select whether a given channel will be emitted in binary or text form.</p> <pre><code>tel fmt &lt;channel&gt; &lt;format&gt;\n</code></pre> <p><code>format</code> is an integer, non-zero signifies the data should be emitted as text.</p>"},{"location":"protocol/diagnostic/#tel-stop","title":"<code>tel stop</code>","text":"<p>Stop emitting all periodic telemetry data.</p>"},{"location":"protocol/diagnostic/#tel-text","title":"<code>tel text</code>","text":"<p>Switch all channels to text mode.</p>"},{"location":"protocol/diagnostic/#conf-configuration","title":"<code>conf</code> - configuration","text":"<p>NOTE: Any commands that change parameters, such as <code>conf set</code>, <code>conf load</code>, or <code>conf default</code>, if executed manually in <code>tview</code> will not automatically update the UI.  <code>tview</code> must be restarted to display the new parameters in the UI.</p>"},{"location":"protocol/diagnostic/#conf-enumerate","title":"<code>conf enumerate</code>","text":"<p>Print the current value of all configurable parameters.</p>"},{"location":"protocol/diagnostic/#conf-get","title":"<code>conf get</code>","text":"<p>Get the value of a single configurable parameter.</p> <pre><code>conf get &lt;item&gt;\n</code></pre>"},{"location":"protocol/diagnostic/#conf-set","title":"<code>conf set</code>","text":"<p>Set the value of a single configurable parameter in RAM.</p> <pre><code>conf set &lt;item&gt; &lt;value&gt;\n</code></pre>"},{"location":"protocol/diagnostic/#conf-load","title":"<code>conf load</code>","text":"<p>Load all configurable values from persistent storage.  This will overwrite their current values in RAM.</p>"},{"location":"protocol/diagnostic/#conf-write","title":"<code>conf write</code>","text":"<p>Write the current value of all configurable parameters from RAM to persistent storage.</p>"},{"location":"protocol/diagnostic/#conf-default","title":"<code>conf default</code>","text":"<p>Update the RAM values of all configurable parameters to their firmware default.</p> <p>NOTE: This only updates RAM, not the persistent storage.  A <code>conf write</code> will be necessary to save these to persistant storage.</p>"},{"location":"protocol/registers/","title":"Register Reference","text":""},{"location":"protocol/registers/#register-usage","title":"Register Usage","text":"<p>Each register may be accessed as potentially multiple data types. This section describes the common mappings, and the semantics of each register.</p>"},{"location":"protocol/registers/#mappings","title":"Mappings","text":"<p>When registers are accessed as integer types, the following mappings are used to encode the underlying floating point values into integer values.</p>"},{"location":"protocol/registers/#current-measured-in-amps","title":"Current (measured in Amps)","text":"<ul> <li>int8 =&gt; 1 LSB =&gt; 1A</li> <li>int16 =&gt; 1 LSB =&gt; 0.1A</li> <li>int32 =&gt; 1 LSB =&gt; 0.001A</li> </ul>"},{"location":"protocol/registers/#torque-measured-in-nm","title":"Torque (measured in N*m)","text":"<ul> <li>int8 =&gt; 1 LSB =&gt; 0.5 N*m</li> <li>int16 =&gt; 1 LSB =&gt; 0.01 N*m</li> <li>int32 =&gt; 1 LSB =&gt; 0.001 N*m</li> </ul>"},{"location":"protocol/registers/#voltage-measured-in-volts","title":"Voltage (measured in Volts)","text":"<ul> <li>int8 =&gt; 1 LSB =&gt; 0.5V</li> <li>int16 =&gt; 1 LSB =&gt; 0.1V</li> <li>int32 =&gt; 1 LSB =&gt; 0.001 V</li> </ul>"},{"location":"protocol/registers/#temperature-measured-in-degrees-celsius","title":"Temperature (measured in degrees Celsius)","text":"<ul> <li>int8 =&gt; 1 LSB =&gt; 1 C</li> <li>int16 =&gt; 1 LSB =&gt; 0.1C</li> <li>int32 =&gt; 1 LSB =&gt; 0.001 C</li> </ul>"},{"location":"protocol/registers/#time-measured-in-seconds","title":"Time (measured in seconds)","text":"<ul> <li>int8 =&gt; 1 LSB =&gt; 0.01s</li> <li>int16 =&gt; 1 LSB =&gt; 0.001s</li> <li>int32 =&gt; 1 LSB =&gt; 0.000001s</li> </ul>"},{"location":"protocol/registers/#position-measured-in-revolutions","title":"Position (measured in revolutions)","text":"<ul> <li>int8 =&gt; 1 LSB =&gt; 0.01 rotation =&gt; 3.6 degrees (range of -1.27 to 1.27)</li> <li>int16 =&gt; 1 LSB =&gt; 0.0001 rotation =&gt; 0.036 degrees (range of -3.2767 to 3.2767)</li> <li>int32 =&gt; 1 LSB =&gt; 0.00001 rotation =&gt; 0.0036 degrees</li> </ul>"},{"location":"protocol/registers/#velocity-measured-in-revolutions-s","title":"Velocity (measured in revolutions / s)","text":"<ul> <li>int8 =&gt; 1 LSB =&gt; 0.1Hz / 36 dps</li> <li>int16 =&gt; 1 LSB =&gt; 0.00025 Hz &gt; 0.09 dps</li> <li>int32 =&gt; 1 LSB =&gt; 0.00001 Hz =&gt; 0.0036 dps</li> </ul>"},{"location":"protocol/registers/#acceleration-measured-in-revolutions-s2","title":"Acceleration (measured in revolutions / s^2)","text":"<ul> <li>int8 =&gt; 1 LSB =&gt; 0.05 l/s^2</li> <li>int16 =&gt; 1 LSB =&gt; 0.001 l/s^2</li> <li>int32 =&gt; 1 LSB =&gt; 0.00001 l/s^2</li> </ul>"},{"location":"protocol/registers/#pwm-and-kpkd-scale-unitless","title":"PWM and kp/kd scale (unitless)","text":"<ul> <li>int8 =&gt; 1 LSB =&gt; (1/127) - 0.007874</li> <li>int16 =&gt; 1 LSB =&gt; (1/32767) - 0.000030519</li> <li>int32 =&gt; 1 LSB =&gt; (1/2147483647) - 4.657e-10</li> </ul>"},{"location":"protocol/registers/#power-w","title":"Power (W)","text":"<ul> <li>int8 =&gt; 1 LSB =&gt; 10.0 W</li> <li>int16 =&gt; 1 LSB =&gt; 0.05 W</li> <li>int32 =&gt; 1 LSB =&gt; 0.0001 W</li> </ul>"},{"location":"protocol/registers/#registers","title":"Registers","text":""},{"location":"protocol/registers/#0x000-mode","title":"0x000 - Mode","text":"<p>Mode: Read/write</p> <p>The current operational mode of the servo.  Not all values are valid to write.</p> <ul> <li>0 =&gt; stopped = writeable, clears faults</li> <li>1 =&gt; fault</li> <li>2,3,4 =&gt; preparing to operate</li> <li>5 =&gt; PWM mode</li> <li>6 =&gt; voltage mode</li> <li>7 =&gt; voltage FOC</li> <li>8 =&gt; voltage DQ</li> <li>9 =&gt; current</li> <li>10 =&gt; position</li> <li>11 =&gt; timeout</li> <li>12 =&gt; zero velocity</li> <li>13 =&gt; stay within</li> <li>14 =&gt; measure inductance</li> <li>15 =&gt; brake</li> </ul> <p>When sending a command, this register must be written before any other registers in the command frame.</p>"},{"location":"protocol/registers/#0x001-position","title":"0x001 - Position","text":"<p>Mode: Read only</p> <p>The current position of the servo, measured in rotations of the output shaft.  The maximum negative integer is reserved and will not be reported.</p>"},{"location":"protocol/registers/#0x002-velocity","title":"0x002 - Velocity","text":"<p>Mode: Read only</p> <p>The current velocity of the servo, measured in Hz at the output shaft.</p>"},{"location":"protocol/registers/#0x003-torque","title":"0x003 - Torque","text":"<p>Mode: Read only</p> <p>The current applied torque as measured at the output shaft.</p>"},{"location":"protocol/registers/#0x004-measured-q-phase-current","title":"0x004 - Measured Q phase current","text":"<p>Mode: Read only</p> <p>The current in the Q phase measured in amperes.</p>"},{"location":"protocol/registers/#0x005-measured-d-phase-current","title":"0x005 - Measured D phase current","text":"<p>Mode: Read only</p> <p>The current in the D phase measured in amperes.</p>"},{"location":"protocol/registers/#0x006-measured-absolution-position","title":"0x006 - Measured absolution position","text":"<p>Mode: Read only</p> <p>If an absolute encoder is configured on the ABS port, its value will be reported here in revolutions.</p>"},{"location":"protocol/registers/#0x007-measured-electrical-power","title":"0x007 - Measured electrical power","text":"<p>Mode: Read only</p> <p>The estimated electrical power applied to the motor if positive.  If negative, power applied to the DC input bus.</p>"},{"location":"protocol/registers/#0x00a-motor-temperature","title":"0x00a - Motor temperature","text":"<p>Mode: Read only</p> <p>The current motor temperature, measured in degrees celsius.  This will only be valid if an NTC thermistor is connected to the TEMP pads, <code>servo.motor_thermistor_ohm</code> is set to the correct resistance, and <code>servo.enable_motor_temperature</code> is set to 1.</p>"},{"location":"protocol/registers/#0x00b-trajectory-complete","title":"0x00b - Trajectory complete","text":"<p>Mode: Read only</p> <p>Non-zero if the current acceleration or velocity limited trajectory is complete, and the controller is following the final velocity.</p>"},{"location":"protocol/registers/#0x00c-home-state","title":"0x00c - Home state","text":"<p>Mode: Read only</p> <ul> <li>0 - relative only - the position is not referenced to anything</li> <li>1 - rotor - the position is referenced to the rotor</li> <li>2 - output - the position has been referenced to the output,   either with an output referenced encoder, or with a \"set output   nearest\" or \"set output exact\" command</li> </ul>"},{"location":"protocol/registers/#0x00d-voltage","title":"0x00d - Voltage","text":"<p>Mode: Read only</p> <p>The current input voltage.</p>"},{"location":"protocol/registers/#0x00e-temperature","title":"0x00e - Temperature","text":"<p>Mode: Read only</p> <p>The current board temperature, measured in degrees celsius.</p>"},{"location":"protocol/registers/#0x00f-fault-code","title":"0x00f - Fault code","text":"<p>Mode: Read only</p> <p>A fault code which will be set if the primary mode is 1 (Fault).</p> <ul> <li>32 - calibration fault - the encoder was not able to sense a   magnet during calibration</li> <li>33 - motor driver fault - the most common reason for this is   undervoltage, moteus attempted to draw more current than the supply   could provide.  Other electrical faults may also report this error,   the <code>drv8323</code> diagnostic tree has more information.</li> <li>34 - over voltage - the bus voltage exceeded <code>servo.max_voltage</code>.   This can happen due to misconfiguration, or if the controller   regenerated power with a supply that cannot sink power and no flux   braking was configured.</li> <li>35 - encoder fault - the encoder readings are not consistent with   a magnet being present.</li> <li>36 - motor not configured - the <code>moteus_tool --calibrate</code>   procedure has not been run on this motor.</li> <li>37 - pwm cycle overrun - an internal firmware error</li> <li>38 - over temperature - the maximum configured temperature has   been exceeded</li> <li>39 - outside limit - an attempt was made to start position control   while outside the bounds configured by <code>servopos.position_min</code> and   <code>servopos.position_max</code>.</li> <li>40 - under voltage - the voltage was too low</li> <li>41 - config changed - a configuration value was changed during   operation that requires a stop</li> <li>42 - theta invalid - no valid commutation encoder is available</li> <li>43 - position invalid - no valid output encoder is available</li> <li>44 - driver enable fault - the MOSFET gate driver could not be   enabled</li> <li>45 - stop position deprecated - an attempt was made to use the   deprecated \"stop position\" feature along with velocity or   acceleration limits.  Prefer to instead command the desired position   directly with a target velocity of 0.0, or secondarily, disable   acceleration and velocity limits.</li> <li>46 - timing violation - internal checks are enabled, and the   controller violated an internal timing constraint</li> <li>47 - bemf feedforward no accel - <code>servo.bemf_feedforward</code> is   configured, but no acceleration limit was specified.  If you   really know what you are doing, you can disable this with   <code>servo.bemf_feedforward_override</code>.</li> <li>48 - invalid limits - <code>servopos.position_min</code> or   <code>servopos.position_max</code> are finite and outside the available   position range</li> </ul> <p>Some non-zero codes can be presented during valid control modes without a fault.  These indicate which, if any, function is limiting the output power of the controller.</p> <ul> <li>96 - <code>servo.max_velocity</code></li> <li>97 - <code>servo.max_power_W</code></li> <li>98 - the maximum system voltage</li> <li>99 - <code>servo.max_current_A</code></li> <li>100 - <code>servo.fault_temperature</code></li> <li>101 - <code>servo.motor_fault_temperature</code></li> <li>102 - the commanded maximum torque</li> <li>103 - <code>servopos.position_min</code> or <code>servopos.position_max</code></li> </ul>"},{"location":"protocol/registers/#0x010-0x011-0x012-pwm-phase-a-b-c","title":"0x010 / 0x011 / 0x012 - PWM phase A / B / C","text":"<p>Mode: Read/write</p> <p>When in Pwm mode, this controls the raw PWM value for phase A, B, and C.  If unspecified, 0.0 is used.</p>"},{"location":"protocol/registers/#0x014-0x15-0x16-voltage-phase-a-b-c","title":"0x014 / 0x15 / 0x16 - Voltage phase A / B / C","text":"<p>Mode: Read/write</p> <p>When in Voltage mode, this controls the voltage applied to phase A, B, and C.  If unspecified, 0.0 is used.</p>"},{"location":"protocol/registers/#0x018-voltage-foc-theta","title":"0x018 - Voltage FOC Theta","text":"<p>Mode: Read/write</p> <p>When in Voltage Foc mode, this controls the desired electrical phase. Integral types use the PWM mapping.  If unspecified, 0.0 is used.</p>"},{"location":"protocol/registers/#0x019-voltage-foc-voltage","title":"0x019 - Voltage FOC Voltage","text":"<p>Mode: Read/write</p> <p>When in Voltage Foc mode, this controls the desired applied phase voltage.  If unspecified, 0.0 is used.</p>"},{"location":"protocol/registers/#0x01a-d-voltage","title":"0x01a - D Voltage","text":"<p>Mode: Read/write</p> <p>When in Voltage Dq mode, this controls the desired applied D voltage. If unspecified, 0.0 is used.</p>"},{"location":"protocol/registers/#0x01b-q-voltage","title":"0x01b - Q Voltage","text":"<p>Mode: Read/write</p> <p>When in kVoltageDq mode, this controls the desired applied Q voltage. If unspecified, 0.0 is used.</p>"},{"location":"protocol/registers/#0x01c-commanded-q-phase-current","title":"0x01c - Commanded Q Phase Current","text":"<p>Mode: Read/write</p> <p>When in Current mode, this controls the desired Q phase current.  If unspecified, 0.0 is used.</p>"},{"location":"protocol/registers/#0x01d-commanded-d-phase-current","title":"0x01d - Commanded D Phase Current","text":"<p>Mode: Read/write</p> <p>When in Current mode, this controls the desired D phase current.  Unless you like burning power, with a BLDC motor you will typically want this set to 0.  If unspecified, 0.0 is used.</p>"},{"location":"protocol/registers/#0x1e-voltage-foc-theta-rate","title":"0x1e - Voltage FOC Theta Rate","text":"<p>Mode: Read/write</p> <p>When in Voltage Foc mode, this controls the rate of change of electrical phase.  Integral types use the velocity mapping.</p>"},{"location":"protocol/registers/#0x020-position-command","title":"0x020 - Position command","text":"<p>Mode: Read/write</p> <p>When in Position mode, this controls the desired position.</p> <p>The maximally negative integer, or NaN for float represents, \"use the current position value\".</p> <p>If unspecified, 0.0 is used.</p> <p>Note, in the absence of any configured or commanded velocity or acceleration limits, the controller will attempt to achieve this position right now subject to the kp and kd constants.</p>"},{"location":"protocol/registers/#0x021-velocity-command","title":"0x021 - Velocity command","text":"<p>Mode: Read/write</p> <p>When in Position mode, advance the desired position at the given velocity in Hz.</p> <p>As a special case, if the 0x020 position is unset, and 0x026 stop position is set, the sign of this is ignored, and is instead selected so that the motor will move towards the stop position.</p> <p>The maximally negative integer, or NaN for float, is treated the same as 0.0.</p> <p>If unspecified, 0.0 is used.</p>"},{"location":"protocol/registers/#0x022-feedforward-torque","title":"0x022 - Feedforward torque","text":"<p>Mode: Read/write</p> <p>When in Position mode, add the given feedforward torque after applying all regular control loops.  Note, this is torque at the output shaft. If unspecified, 0.0 is used.</p>"},{"location":"protocol/registers/#0x023-kp-scale","title":"0x023 - Kp scale","text":"<p>Mode: Read/write</p> <p>When in Position mode, shrink the proportional control term by the given factor.  Integral types are applied as for PWM.  If unspecified, 1.0 is used.</p>"},{"location":"protocol/registers/#0x024-kd-scale","title":"0x024 - Kd scale","text":"<p>Mode: Read/write</p> <p>When in Position mode, shrink the derivative control term by the given factor.  Integral types are applied as for PWM.  This is internally limited to be no more than the kp scale.  If unspecified, 1.0 is used.</p>"},{"location":"protocol/registers/#0x025-maximum-torque","title":"0x025 - Maximum torque","text":"<p>When in Position mode, the maximum torque to be applied.  If unspecified, this defaults to the system-wide configured maximum torque.</p>"},{"location":"protocol/registers/#0x026-commanded-stop-position","title":"0x026 - Commanded stop position","text":"<p>When in Position mode, and a non-zero velocity is commanded, stop motion when reaching the given position.  NaN / maximally negative means no limit is applied.  If unspecified, NaN is used.</p> <p>Note, if the controller is ever commanded to move away from the stop position, say with a velocity command that is inconsistent with the start and stop position, then it will act as if a 0 velocity has been commanded and the current command position equals the stop position.</p>"},{"location":"protocol/registers/#0x027-watchdog-timeout","title":"0x027 - Watchdog timeout","text":"<p>Mode: Read/write</p> <p>This determines the length of time for which this command is valid. If this timeout expires before another command is received, the controller will enter the Timeout state.  The default is 0.0, which means to use the system-wide configured default.  NaN / maximally negative means apply no enforced timeout.</p>"},{"location":"protocol/registers/#0x028-velocity-limit","title":"0x028 - Velocity limit","text":"<p>Mode: Read/write</p> <p>This can be used to override the global velocity limit for internally generated trajectories.</p> <p>If negative, then no limit is applied.</p> <p>If unspecified, it is NaN / maximally negative, which implies to use the global configurable default.</p>"},{"location":"protocol/registers/#0x029-acceleration-limit","title":"0x029 - Acceleration limit","text":"<p>Mode: Read/write</p> <p>This can be used to override the global acceleration limit for internally generated trajectories.</p> <p>If negative, then no limit is applied.</p> <p>If unspecified, it is NaN / maximally negative, which implies to use the global configurable default.</p>"},{"location":"protocol/registers/#0x02a-fixed-voltage-override","title":"0x02a - Fixed voltage override","text":"<p>Mode: Read/write</p> <p>If specified and not-NaN, then the control mode will temporarily be in the \"fixed voltage\" mode, regardless of the current setting of <code>servo.fixed_voltage_mode</code>.</p>"},{"location":"protocol/registers/#0x02b-ki-ilimit-scale","title":"0x02b - Ki ilimit scale","text":"<p>Mode: Read/write</p> <p>When in Position mode, shrink the integral term's windup limit by the given factor.  Integral types are applied as for PWM.  If unspecified, 1.0 is used.</p>"},{"location":"protocol/registers/#0x02c-fixed-current-override","title":"0x02c - Fixed current override","text":"<p>Mode: Read/write</p> <p>If specified, then the control mode will temporarily be in the \"fixed current\" mode.  This is parallel to \"fixed voltage\" mode, but instead of a fixed voltage, a fixed D axis current is controlled.</p>"},{"location":"protocol/registers/#0x02d-ignore-position-bounds","title":"0x02d - Ignore position bounds","text":"<p>Mode: Read/write</p> <p>If specified and non-zero, <code>servopos.position_min</code> and <code>servopos.position_max</code> will be ignore.</p>"},{"location":"protocol/registers/#0x030-proportional-torque","title":"0x030 - Proportional torque","text":"<p>Mode: Read</p> <p>This reports the torque contribution from the proportional term in the PID controller.</p>"},{"location":"protocol/registers/#0x031-integral-torque","title":"0x031 - Integral torque","text":"<p>Mode: Read</p> <p>This reports the torque contribution from the integral term in the PID controller.</p>"},{"location":"protocol/registers/#0x032-derivative-torque","title":"0x032 - Derivative torque","text":"<p>Mode: Read</p> <p>This reports the torque contribution from the derivative term in the PID controller.</p>"},{"location":"protocol/registers/#0x033-feedforward-torque","title":"0x033 - Feedforward torque","text":"<p>Mode: Read</p> <p>This reports the feedforward contribution in the PID controller.</p>"},{"location":"protocol/registers/#0x034-total-control-torque","title":"0x034 - Total control torque","text":"<p>Mode: Read</p> <p>This reports the total commanded torque from the position mode controller.  This is also reported in 0x03a.</p>"},{"location":"protocol/registers/#0x038-control-position","title":"0x038 - Control Position","text":"<p>Mode: Read</p> <p>This reports the current trajectory control position, in modes where that is valid.  When velocity or acceleration limiting is enabled, the control position will follow the desired limits to achieve the command position.</p>"},{"location":"protocol/registers/#0x039-control-velocity","title":"0x039 - Control Velocity","text":"<p>Mode: Read</p> <p>This reports the current velocity control value, in modes where that is valid.  When velocity or acceleration limiting is enabled, the control velocity will follow the desired limits to achieve the control position and velocity.</p>"},{"location":"protocol/registers/#0x03a-control-torque","title":"0x03a - Control Torque","text":"<p>Mode: Read</p> <p>The torque commanded by the control loop.  This is the same as 0x034.</p>"},{"location":"protocol/registers/#0x03b-position-error","title":"0x03b - Position Error","text":"<p>Mode: Read</p> <p>The current sensed position minus the control position.</p>"},{"location":"protocol/registers/#0x03c-velocity-error","title":"0x03c - Velocity Error","text":"<p>Mode: Read</p> <p>The current sensed velocity minus the control velocity.</p>"},{"location":"protocol/registers/#0x03d-torque-error","title":"0x03d - Torque Error","text":"<p>Mode: Read</p> <p>The current sensed torque minus the control torque.</p>"},{"location":"protocol/registers/#0x040-stay-within-lower-bound","title":"0x040 - Stay within lower bound","text":"<p>Mode: Read/write</p> <p>When in Stay Within mode, this controls the minimum allowable position.  The maximally negative integer or NaN for float represents, \"there is no lower bound\".  When special or the position is above this bound (and also respecting the optional upper bound), only a feedforward torque is applied.  When outside this bound, the PID controller is used to force the position back to the bound.  If unspecified, 0.0 is used.</p>"},{"location":"protocol/registers/#0x041-stay-within-upper-bound","title":"0x041 - Stay within upper bound","text":"<p>Mode: Read/write</p> <p>When in Stay Within mode, this controls the maximum allowable position.  The maximally negative integer, or NaN for float represents, \"there is no upper bound\". When special or the position is below this bound (and also respecting the optional lower bound), only a feedforward torque is applied.  When outside this bound, the PID controller is used to force the position back to the bound.  If unspecified, 0.0 is used.</p>"},{"location":"protocol/registers/#0x042-feedforward-torque","title":"0x042 - Feedforward torque","text":"<p>A shadow of the 0x022 register.</p>"},{"location":"protocol/registers/#0x043-kp-scale","title":"0x043 - Kp scale","text":"<p>A shadow of the 0x023 register.</p>"},{"location":"protocol/registers/#0x044-kd-scale","title":"0x044 - Kd scale","text":"<p>A shadow of the 0x024 register.</p>"},{"location":"protocol/registers/#0x045-maximum-torque","title":"0x045 - Maximum torque","text":"<p>A shadow of the 0x025 register.</p>"},{"location":"protocol/registers/#0x046-watchdog-timeout","title":"0x046 - Watchdog timeout","text":"<p>A shadow of the 0x027 register.</p>"},{"location":"protocol/registers/#0x047-ki-ilimit-scale","title":"0x047 - Ki ilimit scale","text":"<p>A shadow of the 0x02b register.</p>"},{"location":"protocol/registers/#0x048-ignore-position-bounds","title":"0x048 - Ignore position bounds","text":"<p>A shadow of the 0x02d register.</p>"},{"location":"protocol/registers/#0x050-encoder-0-position","title":"0x050 - Encoder 0 Position","text":"<p>Mode: Read only</p> <p>Reports the current filtered position of the encoder configured in slot 0.</p>"},{"location":"protocol/registers/#0x051-encoder-0-velocity","title":"0x051 - Encoder 0 Velocity","text":"<p>Mode: Read only</p> <p>Reports the current filtered velocity of the encoder configured in slot 0.</p>"},{"location":"protocol/registers/#0x052-encoder-1-position","title":"0x052 - Encoder 1 Position","text":"<p>Mode: Read only</p> <p>Reports the current filtered position of the encoder configured in slot 1.</p>"},{"location":"protocol/registers/#0x053-encoder-1-velocity","title":"0x053 - Encoder 1 Velocity","text":"<p>Mode: Read only</p> <p>Reports the current filtered velocity of the encoder configured in slot 1.</p>"},{"location":"protocol/registers/#0x054-encoder-2-position","title":"0x054 - Encoder 2 Position","text":"<p>Mode: Read only</p> <p>Reports the current filtered position of the encoder configured in slot 2.</p>"},{"location":"protocol/registers/#0x055-encoder-2-velocity","title":"0x055 - Encoder 2 Velocity","text":"<p>Mode: Read only</p> <p>Reports the current filtered velocity of the encoder configured in slot 2.</p>"},{"location":"protocol/registers/#0x058-encoder-validity","title":"0x058 - Encoder Validity","text":"<p>Mode: Read only</p> <p>Returns a bitfield, where bit 0 indicates whether encoder 0 is active, bit 1 indicates whether encoder 1 is active, etc.</p> Bit Value 0 Source 0 Theta 1 Source 0 Velocity 2 Source 1 Theta 3 Source 1 Velocity 4 Source 2 Theta 5 Source 2 Velocity"},{"location":"protocol/registers/#0x05c-aux1-gpio-command","title":"0x05c - Aux1 GPIO Command","text":"<p>Mode: Read/write</p> <p>The current output command for any GPIOs configured as an output on aux1 as a bitfield.  Not all bits may be used, as bit 0 is always for pin 1, whether or not it is configured as a GPIO output.</p>"},{"location":"protocol/registers/#0x05d-aux2-gpio-command","title":"0x05d - Aux2 GPIO Command","text":"<p>Mode: Read/write</p> <p>The current output command for any GPIOs configured as an output on aux2 as a bitfield.  Not all bits may be used, as bit 0 is always for pin 1, whether or not it is configured as a GPIO output.</p>"},{"location":"protocol/registers/#0x05e-aux1-gpio-status","title":"0x05e - Aux1 GPIO Status","text":"<p>Mode: Read only</p> <p>The current input value of any GPIOs configured as an input on aux1 as a bitfield.  Not all bits may be used, as bit 0 is always for pin 1, whether or not it is configured as a GPIO input.</p>"},{"location":"protocol/registers/#0x05f-aux2-gpio-status","title":"0x05f - Aux2 GPIO Status","text":"<p>Mode: Read only</p> <p>The current input value of any GPIOs configured as an input on aux2 as a bitfield.  Not all bits may be used, as bit 0 is always for pin 1, whether or not it is configured as a GPIO input.</p>"},{"location":"protocol/registers/#0x0600x064-aux1-analog-inputs","title":"0x060/0x064 - Aux1 Analog Inputs","text":"<p>Mode: Read only</p> <p>The current input value of any analog inputs configured on aux1.  The registers are associated with pins 1-5, regardless of whether they are configured as an analog input.  Each value is scaled as a PWM from 0 to 1.</p>"},{"location":"protocol/registers/#0x0680x06c-aux2-analog-inputs","title":"0x068/0x06c - Aux2 Analog Inputs","text":"<p>Mode: Read only</p> <p>The current input value of any analog inputs configured on aux2.  The registers are associated with pins 1-5, regardless of whether they are configured as an analog input.  Each value is scaled as a PWM from 0 to 1.</p>"},{"location":"protocol/registers/#0x070-millisecond-counter","title":"0x070 - Millisecond Counter","text":"<p>Mode: Read only</p> <p>Increments once per millisecond.  It wraps at the maximum value for the queried type to the minimum value for that type.  For floating point types, it counts integers from 0 to 8388608.</p>"},{"location":"protocol/registers/#0x071-clock-trim","title":"0x071 - Clock Trim","text":"<p>Mode: Read/write</p> <p>An integer which can trim the clock rate of the microprocessor on the moteus controller.  Positive values speed it up and negative values slow it down.  Each integer step roughly corresponds to a 0.25% change in speed.</p> <p>WARNING: Changing the speed affects all processes driven by the microcontroller, including CAN communication.  Thus setting this to a non-zero value may prevent future CAN communications.</p>"},{"location":"protocol/registers/#0x0760x07a-aux1-pwm-outputs","title":"0x076/0x07a - Aux1 PWM Outputs","text":"<p>Mode: Read/write</p> <p>The current output PWM value for the given pin on Aux1.  PWM mapping is used for integral types.</p>"},{"location":"protocol/registers/#0x07b0x07f-aux2-pwm-outputs","title":"0x07b/0x07f - Aux2 PWM Outputs","text":"<p>Mode: Read/write</p> <p>The current output PWM value for the given pin on Aux1.  PWM mapping is used for integral types.</p>"},{"location":"protocol/registers/#0x100-model-number","title":"0x100 - Model Number","text":"<p>Name: Model Number Mode: Read only</p> <p>This returns a 32 bit model number.</p>"},{"location":"protocol/registers/#0x101-firmware-version","title":"0x101 - Firmware Version","text":"<p>Mode: Read only</p> <p>This returns a 32 bit firmware version, encoded bytewise as major.minor.micro.  i.e. 0x010304 is version 1.3.4</p>"},{"location":"protocol/registers/#0x102-register-map-version","title":"0x102 - Register map version","text":"<p>Mode: Read only</p> <p>This returns a number that indicates how to interpret all registers.</p>"},{"location":"protocol/registers/#0x110-multiplex-id","title":"0x110 - Multiplex ID","text":"<p>Name: Multiplex ID Mode: Configurable</p> <p>This controls the primary ID used to access the device over the multiplex RS485 bus.  It can only be between 1 and 127.  (0 is reserved as the broadcast address).</p>"},{"location":"protocol/registers/#0x120-0x122-serial-number","title":"0x120 - 0x122 - Serial Number","text":"<p>Name: Serial Number Mode: Read only</p> <p>This returns a 96 bit serial number, least significant word first.</p>"},{"location":"protocol/registers/#0x130-set-output-nearest","title":"0x130 - Set Output Nearest","text":"<p>Mode: Write only</p> <p>When sent, this causes the servo to select a whole number of internal motor rotations so that the final position is as close to the given position as possible.</p>"},{"location":"protocol/registers/#0x131-set-output-exact","title":"0x131 - Set Output Exact","text":"<p>Mode: Write only</p> <p>When sent, the servo will force the output position to be the exact specified value.</p>"},{"location":"protocol/registers/#0x132-require-reindex","title":"0x132 - Require Reindex","text":"<p>Mode: Write only</p> <p>When sent with any value, the servo will require that any index position be re-located before control can begin.  Regardless, the position will reset to an arbitrary value consistent with the current encoder settings.</p>"},{"location":"protocol/registers/#0x133-recapture-position-and-velocity","title":"0x133 - Recapture Position and Velocity","text":"<p>Mode: Write only</p> <p>When sent with any value, and if in \"position\" mode, the servo will re-initialize the current control position and velocity to the sensed values.  This also forces any pre-existing position integrative term to zero.  It is expected that this will mostly be used when the current applied torque is 0, either because of an in-place maximum torque limit of zero, or because of an in-place kp and kd scale of zero.</p>"},{"location":"protocol/registers/#0x140-driver-fault-1","title":"0x140 - Driver Fault 1","text":"<p>Mode: Read only</p> <p>The exact bitfield reported by the motor driver in fault conditions for fault register 1.  Up to 16 bits may be set.  This will only be non-zero if the current mode is fault (1) and the fault code is 33 (motor driver fault).</p>"},{"location":"protocol/registers/#0x141-driver-fault-2","title":"0x141 - Driver Fault 2","text":"<p>Mode: Read only.</p> <p>The exact bitfield reported by the motor driver in fault conditions for fault register 2.  Up to 16 bits may be set.  This will only be non-zero if the current mode is fault (1) and the fault code is 33 (motor driver fault).</p>"},{"location":"protocol/registers/#0x150-0x153-uuid","title":"0x150 - 0x153 - UUID","text":"<p>Name: UUID Mode: Read only, int32 only</p> <p>This returns a 128 bit UUID, this is the value printed on mjbots packaging and returned by <code>moteus_tool --info</code></p>"},{"location":"protocol/registers/#0x154-0x157-uuid-mask","title":"0x154 - 0x157 - UUID Mask","text":"<p>Name: UUID Mode: Write only, int32 only</p> <p>If one or more of these fields are written, then the entire frame after this point will be discarded unless the devices corresponding UUID matches what was written.</p>"},{"location":"protocol/registers/#0x158-uuid-mask-functional","title":"0x158 UUID Mask Functional","text":"<p>Name: UUID Filter capable Mode: Read only</p> <p>Returns non-zero if the UUID mask is usable.</p>"},{"location":"reference/client-tools/","title":"Client Tools","text":""},{"location":"reference/client-tools/#tview-usage","title":"tview usage","text":"<p>tview can monitor and control 1 or more devices simultaneously.  It can be started with:</p> <pre><code>python3 -m moteus_gui.tview --target 1[,2,3]...\n</code></pre> <p>When running, the configuration for each can be modified in the left hand tab, and live telemetry values can be displayed or plotted from the right hand tab.  diagnostic mode commands may be issued in the bottom terminal window.</p> <p>A simple command and scripting language beyond the diagnostic protocol is available within the tview terminal window.</p>"},{"location":"reference/client-tools/#communicating-with-a-specific-device","title":"Communicating with a specific device","text":"<p>If more than one device is available, commands can be sent to a specific device by prefixing the command with <code>ID&gt;</code>.  For instance, to send a stop command to ID #2, you can do:</p> <pre><code>2&gt;d stop\n</code></pre> <p>The 'A' character can be used to send to all devices simultaneously.</p> <pre><code>A&gt;d stop\n</code></pre>"},{"location":"reference/client-tools/#sending-multiple-commands-at-once","title":"Sending multiple commands at once","text":"<p>The <code>&amp;&amp;</code> token may be used to separate individual commands, which will be issued back to back.  For instance:</p> <pre><code>1&gt;d stop &amp;&amp; 2&gt;d stop\n</code></pre> <p>Will send the command to both devices.</p>"},{"location":"reference/client-tools/#delays","title":"Delays","text":"<p>A delay may be inserted into a sequence of commands by entering an integer number of milliseconds prefixed by the colon (':') character.  For instance:</p> <pre><code>d pos nan 0.5 1 s0.5 &amp;&amp; :1000 &amp;&amp; d stop\n</code></pre> <p>Will command a position mode, wait 1s, then command a stop.</p>"},{"location":"reference/client-tools/#waiting-for-a-trajectory-to-complete","title":"Waiting for a trajectory to complete","text":"<p>A sequence of commands can be paused until a controller has finished its trajectory using the <code>?</code> character.</p> <pre><code>d pos 0 0 nan a2 &amp;&amp; ? &amp;&amp; d pos 1 0 nan a2\n</code></pre> <p>Will move to position 0, wait until that motion is complete, then move to position 1, all with an acceleration limit of 2.</p> <p>Specific devices can be queried by following the question mark with an ID number.</p> <pre><code>2&gt;d pos 0 0 nan a2 &amp;&amp; 1&gt;d pos 10 0 0 nan a2 &amp;&amp; ?2 &amp;&amp; 2&gt;d stop\n</code></pre>"},{"location":"reference/client-tools/#calibration","title":"Calibration","text":"<p>Assuming your controller has firmware installed already, you can calibrate the controller using the following procedure.</p> <pre><code>python3 -m moteus.moteus_tool --target 1 --calibrate\n</code></pre> <p>WARNING: Any attached motor must be able to spin freely.  It will be spun in both directions and at high speed.</p> <p>After calibrating for an entirely new type of motor, you may need to adjust PID gains before the motor will perform acceptably, and/or configure <code>motor_position.rotor_to_output_ratio</code>.</p>"},{"location":"reference/client-tools/#setting-the-zero-offset","title":"Setting the \"zero offset\"","text":"<p>The moteus controller can locate positions within one revolution after being power cycled, and will start with the reported position being between -0.5 and 0.5.  The physical zero position can be set using the following command:</p> <pre><code>python3 -m moteus.moteus_tool --target 1 --zero-offset\n</code></pre>"},{"location":"reference/client-tools/#configuring-the-can-fd-transport","title":"Configuring the CAN-FD transport","text":"<p><code>moteus_tool</code> and <code>tview</code> can be configured to communicate with a moteus controller through a variety of transports.  By default, it will attempt to autodetect either a fdcanusb or socketcan interface.</p> <p>To force usage of a particular fdcanusb, you can use:</p> <pre><code>python3 -m moteus.moteus_tool --fdcanusb /path/to/fdcanusb\n</code></pre> <p>To force a particular python-can method, you can use:</p> <pre><code>python3 -m moteus.moteus_tool --can-iface socketcan --can-chan can0\n</code></pre> <p>where <code>--can-iface</code> specifies the \"interface\" for python-can and <code>--can-chan</code> specifies the \"channel\".</p> <p>Note, these are in addition to any other <code>moteus_tool</code> or <code>tview</code> options that may be desired.</p>"},{"location":"reference/configuration/","title":"Configuration Parameters","text":"<p>This section describes the configurable values which are most likely to be modified for end-user applications.  Changes to all values take effect immediately.  This may mean, that for instance, it is wise to stop control loops before drastically changing control parameters.  Or maybe not, it depends upon your goals.</p>"},{"location":"reference/configuration/#idid","title":"<code>id.id</code>","text":"<p>The servo ID presented on the CAN bus.  After this is modified, you need to immediately adjust which servo ID you communicate with in order to continue communication or save the parameters.</p>"},{"location":"reference/configuration/#canprefix","title":"<code>can.prefix</code>","text":"<p>A 13 bit integer used as the upper 13 bits for the ID of all CAN communication.  As with <code>id.id</code> this takes effect immediately, so after changing it, communication must be restarted with the correct prefix in order to do things like save the configuration.</p>"},{"location":"reference/configuration/#servoposposition_min","title":"<code>servopos.position_min</code>","text":"<p>The minimum allowed control position value, measured in rotations.  If NaN, then no limit is applied.</p>"},{"location":"reference/configuration/#servoposposition_max","title":"<code>servopos.position_max</code>","text":"<p>The maximum allowed control position value, measured in rotations.  If NaN, then no limit is applied.</p>"},{"location":"reference/configuration/#servopid_position","title":"<code>servo.pid_position</code>","text":"<p>These configure the position mode PID controller.</p> <ul> <li><code>kp/ki/kd</code> - PID gains with units of:</li> <li>kp - Nm per rotation</li> <li>ki - Nm/s per rotation</li> <li>kd - Nm per rotation/s</li> <li><code>iratelimit</code> - The maximum rate at which the integral term can    wind up, in N*m/s.  &lt;0 means \"no limit\"</li> <li><code>ilimit</code> - The total maximum I term, in Nm</li> <li><code>max_desired_rate</code> - If non-zero, the commanded position is   limited to change at this rate in Hz.</li> </ul> <p>Note, these values are in physical units.  Thus a <code>kp</code> value of 1, means that for 1 revolution of error at the output, 1 Nm of corrective torque will be applied.  Similarly, with a <code>kd</code> value of 1, 1 revolution per second of error will result in 1 Nm of corrective torque.  Doubly note that these values are measured at the output, thus after any scaling in position, velocity, and torque implied by <code>motor_position.rotor_to_output_ratio</code>.</p>"},{"location":"reference/configuration/#servopid_dq","title":"<code>servo.pid_dq</code>","text":"<p>These have the same semantics as the position mode PID controller, and affect the current control loop.</p>"},{"location":"reference/configuration/#servodefault_velocity_limit-servodefault_accel_limit","title":"<code>servo.default_velocity_limit</code> / <code>servo.default_accel_limit</code>","text":"<p>Limits to be placed on trajectories generated within moteus.  If either is <code>nan</code>, then that limit is unset.  The limits may also be overriden individually on a per command basis.  The semantics of the limits are as follows:</p> <ul> <li> <p>Neither set (both nan) In this case, position and velocity   commands take immediate effect.  The control position will be   initialized to the command position, and the control velocity will   be set to the command velocity.  The control position will advance   at the given velocity indefinitely, or until the command stop   position is reached.</p> </li> <li> <p>Either set: If x_c is the command position, v_c is the command   velocity, and t is the time from receipt of the command, the   semantics can be described as: \"match the trajectory defined by x =   x_c + v_c * t\".</p> </li> </ul> <p>If the acceleration limit is set, the above is effected by   commanding accelerations of either [-accel_limit, 0, accel_limit].   If an acceleration limit is not set, then the velocity will change   instantaneously.</p> <p>If the velocity limit is set, then the intermediate velocities will   obey \"-velocity_limit &lt; velocity &lt; +velocity_limit\".  If it is not   set, then the velocities may grow to arbitrary magnitude.</p> <p>NOTE: This is limited internally to be no more than <code>servo.max_velocity</code>.</p>"},{"location":"reference/configuration/#servoinertia_feedforward","title":"<code>servo.inertia_feedforward</code>","text":"<p>When set to non-zero, and acceleration limits are currently in effect, this will apply a feedforward torque equal to the current acceleration multiplied by this configurable value.  This can be used to improve response transients for short movements, where the acceleration period is not long enough for the normal position PID to track well.</p> <p>In an ideal world, you would set this to the moment of inertia of your system in measured in kg * m^2.</p>"},{"location":"reference/configuration/#servovoltage_mode_control","title":"<code>servo.voltage_mode_control</code>","text":"<p>When set to non-zero, the current control loop is not closed, and all current commands in amperes are instead treated as voltage mode commands in volts related by the calibrated phase resistance.  For high winding resistance motors, the default current sense resistors are too small for accurate current sensing, resulting in significant cogging torque and current sense noise.  If replacing the current sense resistors is not an option, this flag can be used to achieve smooth control.  The downside is that the actual torque will no longer follow the applied torque accurately at speed, or in the face of external disturbances.</p> <p>When set, the <code>servo.pid_dq</code> configuration values no longer affect anything.</p>"},{"location":"reference/configuration/#servofixed_voltage_mode","title":"<code>servo.fixed_voltage_mode</code>","text":"<p>If non-zero, then no feedback based control of either position or current is done.  Instead, a fixed voltage is applied to the phase terminals based on the current commanded position and the configured number of motor poles.  In this mode, the encoder and current sense resistors are not used at all for control.</p> <p>This is a similar control mode to inexpensive brushless gimbal controllers, and relies on burning a fixed amount of power in the motor windings continuously.</p> <p>When this mode is active, the reported position and velocity will be 0 when the drive is disabled, and exactly equal to the control position when it is enabled.</p> <p>Various derating limits are inoperative in this mode:  * torque derating for temperature  * torque derating when outside position bounds  * the maximum current limit  * the commanded maximum torque</p> <p>A fault will still be triggered for over-temperature.</p>"},{"location":"reference/configuration/#servofixed_voltage_control_v","title":"<code>servo.fixed_voltage_control_V</code>","text":"<p>In the fixed voltage control mode, the voltage to apply to the output.</p>"},{"location":"reference/configuration/#servomax_position_slip","title":"<code>servo.max_position_slip</code>","text":"<p>When finite, this enforces a limit on the difference between the control position and the current measured position measured in revolutions.  It can be used to prevent \"catching up\" when the controller is used in velocity mode.</p>"},{"location":"reference/configuration/#servomax_velocity_slip","title":"<code>servo.max_velocity_slip</code>","text":"<p>When finite, this enforces a limit on the difference between the control velocity and the current measured velocity, measured i Hz.  It can be used to ensure that acceleration limits are obeyed in velocity mode when external torques exceed the maximum.  If used, typically <code>servo.max_position_slip</code> must be relatively small to avoid instability.</p>"},{"location":"reference/configuration/#servomax_voltage","title":"<code>servo.max_voltage</code>","text":"<p>If the input voltage reaches this value, a fault is triggered and all torque is stopped.</p>"},{"location":"reference/configuration/#servomax_power_w","title":"<code>servo.max_power_W</code>","text":"<p>If set, set the allowable maximum power to the lower of this and the factory board power profile.</p>"},{"location":"reference/configuration/#servooverride_board_max_power","title":"<code>servo.override_board_max_power</code>","text":"<p>If true, then <code>servo.max_power_W</code> is used as the power limit even if it is larger than the factory board power profile.</p>"},{"location":"reference/configuration/#servopwm_rate_hz","title":"<code>servo.pwm_rate_hz</code>","text":"<p>The PWM rate to use, defaulting to 30000.  Allowable values are between 15000 and 60000.  Lower values increase efficiency, but limit peak power and reduce the maximum speed and control bandwidth.</p>"},{"location":"reference/configuration/#servoderate_temperature","title":"<code>servo.derate_temperature</code>","text":"<p>Torque begins to be limited when the temperature reaches this value.</p>"},{"location":"reference/configuration/#servofault_temperature","title":"<code>servo.fault_temperature</code>","text":"<p>If the temperature reaches this value, a fault is triggered and all torque is stopped.</p>"},{"location":"reference/configuration/#servoenable_motor_temperature","title":"<code>servo.enable_motor_temperature</code>","text":"<p>If true, then the motor temperature will be sensed via the TEMP pads on the board.</p>"},{"location":"reference/configuration/#servomotor_derate_temperature","title":"<code>servo.motor_derate_temperature</code>","text":"<p>Torque begins to be limited when the motor temperature reaches this value.</p>"},{"location":"reference/configuration/#servomotor_fault_temperature","title":"<code>servo.motor_fault_temperature</code>","text":"<p>If the motor temperature reaches this value, a fault is triggered and all torque is stopped.</p>"},{"location":"reference/configuration/#servoflux_brake_margin_voltage","title":"<code>servo.flux_brake_margin_voltage</code>","text":"<p>Selects the flux braking point relative to the currently configured <code>servo.max_voltage</code>.  <code>flux braking point = max_voltage - flux_brake_margin_voltage</code>.</p> <p>When the input voltage is above the braking point, the controller causes the motor to act as a \"virtual resistor\" with resistance <code>servo.flux_brake_resistance_ohm</code>.  All extra energy is dumped into the D phase of the motor.  This can be used to handle excess regenerative energy if the input DC link is incapable of accepting sufficient energy.</p>"},{"location":"reference/configuration/#servomax_current_a","title":"<code>servo.max_current_A</code>","text":"<p>Phase current will never be used more than this value.  It can be decreased to limit the total power used by the controller.  Increasing beyond the factory configured value can result in hardware damage.</p>"},{"location":"reference/configuration/#servomax_velocity","title":"<code>servo.max_velocity</code>","text":"<p>Output power will be limited if the velocity exceeds this threshold.</p>"},{"location":"reference/configuration/#servomax_velocity_derate","title":"<code>servo.max_velocity_derate</code>","text":"<p>Once velocity reaches the max_velocity plus this value, allowed output power is reduced to 0.</p>"},{"location":"reference/configuration/#servorotation_","title":"<code>servo.rotation_*</code>","text":"<p>These values configure a higher order torque model for a motor.</p> <ul> <li><code>servo.rotation_current_cutoff_A</code> if the phase current is less than   this value, then the linear relationship implied by <code>motor.v_per_hz</code>   is used.</li> </ul> <p>Once above that cutoff, the following formula is used to determine torque from phase current:</p> <pre><code>torque = cutoff * tc + torque_scale * log2(1 + (I - cutoff) * current_scale)\n</code></pre> <p>Where <code>tc</code> is the torque constant derived from <code>motor.v_per_hz</code>.</p> <p>This model is not automatically calibrated, and needs to be determined and configured manually.</p>"},{"location":"reference/configuration/#servodefault_timeout_s","title":"<code>servo.default_timeout_s</code>","text":"<p>When sending position mode commands over CAN, there is an optional watchdog timeout.  If commands are not received at a certain rate, then the controller will latch into the \"position timeout\" state, requiring a stop command to resume operation.  This configuration value controls the length of time that the controller will wait after receiving a command before entering this state.  If set to <code>nan</code> then the controller will never enter this timeout state.</p> <p>It may be overidden on a per-command basis with the 0x027 register or the <code>t</code> optional flag of the <code>d pos</code> command for the diagnostic interface.</p>"},{"location":"reference/configuration/#servotimeout_max_torque_nm","title":"<code>servo.timeout_max_torque_Nm</code>","text":"<p>When in the \"position timeout\" mode the controller acts to damp the output.  This parameter controls the maximum torque available for such damping.</p>"},{"location":"reference/configuration/#servotimeout_mode","title":"<code>servo.timeout_mode</code>","text":"<p>Selects what behavior will take place in the position timeout mode. The allowable values are a subset of the top level modes.</p> <ul> <li>0 - \"stopped\" - the driver is disengaged</li> <li>10 - \"decelerate to 0 velocity and hold position\"</li> <li>12 - \"zero velocity\"</li> <li>15 - \"brake\"</li> </ul> <p>For mode 10, <code>servo.default_velocity_limit</code> and <code>servo.default_accel_limit</code> are used to control the deceleration profile to zero speed.  The default PID gains are used.  The only limit on torque when in this timeout mode is <code>servo.max_current_A</code>.</p>"},{"location":"reference/configuration/#servomotor_thermistor_ohm","title":"<code>servo.motor_thermistor_ohm</code>","text":"<p>The resistance of any attached motor NTC thermistor as measured at 25C in ohms.</p>"},{"location":"reference/configuration/#aux12pinsxmode","title":"<code>aux[12].pins.X.mode</code>","text":"<p>Selects what functionality will be used on the given pin.</p> <ul> <li>0 - NC - Not connected (or used for onboard SPI)</li> <li>1 - SPI - Used for one of CLK, MISO, or MOSI</li> <li>2 - SPI CS - Used for SPI CS</li> <li>3 - UART</li> <li>4 - Software quadrature</li> <li>5 - Hardware quadrature</li> <li>6 - Hall</li> <li>7 - Index</li> <li>8 - Sine</li> <li>9 - Cosine</li> <li>10 - Step (not implemented)</li> <li>11 - Dir (not implemented)</li> <li>12 - RC PWM (not implemented)</li> <li>13 - I2C</li> <li>14 - Digital input</li> <li>15 - Digital output</li> <li>16 - Analog input</li> <li>17 - PWM output</li> </ul>"},{"location":"reference/configuration/#aux12pinsxpull","title":"<code>aux[12].pins.X.pull</code>","text":"<p>Configures optional pullup or pulldown on each pin.  Not all pullup options will be used with every mode.  Additionally, the 2 aux2 pins on moteus 4.5/8/11 have hard-installed 2k ohm pullups regardless of these settings.</p> <ul> <li>0 - no pullup or pulldown</li> <li>1 - pull up</li> <li>2 - pull down</li> <li>3 - open drain (not implemented)</li> </ul>"},{"location":"reference/configuration/#aux12i2ci2c_hz","title":"<code>aux[12].i2c.i2c_hz</code>","text":"<p>The frequency to operate the I2C bus at.  Between 50000 and 400000.</p>"},{"location":"reference/configuration/#aux12i2ci2c_mode","title":"<code>aux[12].i2c.i2c_mode</code>","text":"<p>What I2C mode to use.</p>"},{"location":"reference/configuration/#aux12i2cdevicesxtype","title":"<code>aux[12].i2c.devices.X.type</code>","text":"<p>What I2C device to expect.</p> <ul> <li>0 - disabled</li> <li>1 - AS5048</li> <li>2 - AS5600</li> </ul>"},{"location":"reference/configuration/#aux12i2cdevicesxaddress","title":"<code>aux[12].i2c.devices.X.address</code>","text":"<p>The I2C address to use.</p>"},{"location":"reference/configuration/#aux12i2cdevicesxpoll_ms","title":"<code>aux[12].i2c.devices.X.poll_ms</code>","text":"<p>How often in milliseconds to poll the device for more data.  Must no less than 5.</p>"},{"location":"reference/configuration/#aux12spimode","title":"<code>aux[12].spi.mode</code>","text":"<p>The type of SPI device.</p> <ul> <li>0 - The onboard AS5047P (CPR == 16384). Only valid for aux1.  If   selected, the CLK, MOSI, and MISO lines must be either NC or   selected as SPI.</li> <li>1 - Disabled.</li> <li>2 - AS5047P (CPR == 16384)</li> <li>3 - iC-PZ</li> <li>4 - MA732 (CPR == 65536)</li> <li>5 - MA600 (CPR == 65536)</li> <li>8 - AMT22 (CPR == 16384)</li> </ul> <p>NOTE: iC-PZ devices require significant configuration and calibration before use.  Diagnostic mode commands are provided for low level access.</p>"},{"location":"reference/configuration/#aux12spirate_hz","title":"<code>aux[12].spi.rate_hz</code>","text":"<p>The frequency to operate the SPI bus at.  The default is 12000000.</p>"},{"location":"reference/configuration/#aux12uartmode","title":"<code>aux[12].uart.mode</code>","text":"<p>The type of UART device.</p> <ul> <li>0 - Disabled</li> <li>1 - RLS AksIM-2</li> <li>2 - Tunnel</li> <li>3 - Per-control cycle debug information (undocumented)</li> <li>4 - CUI AMT21x series RS422</li> </ul> <p>When the tunnel mode is selected, data may be sent or received using the CAN diagnostic protocol.  For aux1, use diagnostic channel 2.  For aux2, use diagnostic channel 3.</p>"},{"location":"reference/configuration/#aux12uartbaud_rate","title":"<code>aux[12].uart.baud_rate</code>","text":"<p>The baud rate to use for the UART.</p>"},{"location":"reference/configuration/#aux12uartpoll_rate_us","title":"<code>aux[12].uart.poll_rate_us</code>","text":"<p>For encoder modes, the interval at which to poll the encoder for new position information.</p>"},{"location":"reference/configuration/#aux12uartrs422","title":"<code>aux[12].uart.rs422</code>","text":"<p>Enable the RS422 transceiver.  This is only valid for 'aux1', and requires that pin D and E (<code>aux1.pins.3</code> and <code>aux1.pins.4</code>) be used for UART.</p>"},{"location":"reference/configuration/#aux12uartcui_amt21_address","title":"<code>aux[12].uart.cui_amt21_address</code>","text":"<p>Select the CUI AMT21 address to communicate with.  The default is 0x54 (84 decimal), which is the default address CUI AMT21 encoders are configured with.</p>"},{"location":"reference/configuration/#aux12quadratureenabled","title":"<code>aux[12].quadrature.enabled</code>","text":"<p>True/non-zero if quadrature input should be read from this port.</p>"},{"location":"reference/configuration/#aux12quadraturecpr","title":"<code>aux[12].quadrature.cpr</code>","text":"<p>The number of counts per revolution of the quadrature input.  If used as a source, then this CPR must match the one configured in the source.</p>"},{"location":"reference/configuration/#aux12hallenabled","title":"<code>aux[12].hall.enabled</code>","text":"<p>True/non-zero if hall effect sensors should be read from this port.</p>"},{"location":"reference/configuration/#aux12hallpolarity","title":"<code>aux[12].hall.polarity</code>","text":"<p>A bitmask to XOR with the 3 hall phases.</p>"},{"location":"reference/configuration/#aux12indexenabled","title":"<code>aux[12].index.enabled</code>","text":"<p>True/non-zero if an index input be read from this port.</p>"},{"location":"reference/configuration/#aux12sine_cosineenabled","title":"<code>aux[12].sine_cosine.enabled</code>","text":"<p>True/non-zero if a sine/cosine input should be read from this port.</p>"},{"location":"reference/configuration/#aux12sine_cosinecommon","title":"<code>aux[12].sine_cosine.common</code>","text":"<p>The common mode voltage to use for the sine cosine.  The sampling is done with 12 bits, so 2048 would be exactly 0.5 * 3.3V.  However, it is best to calibrate this with actual readings as observed over the diagnostic protocol for optimal performance.</p>"},{"location":"reference/configuration/#aux12i2c_startup_delay_ms","title":"<code>aux[12].i2c_startup_delay_ms</code>","text":"<p>A delay in milliseconds after power-on (or upon reconfiguring), before I2C devices associated with this auxiliary port are first used.</p>"},{"location":"reference/configuration/#aux12pwm_period_us","title":"<code>aux[12].pwm_period_us</code>","text":"<p>The period in microseconds to be used for PWM outputs on this auxiliary port.</p>"},{"location":"reference/configuration/#motor_positionsourcesxaux_number","title":"<code>motor_position.sources.X.aux_number</code>","text":"<p>1 for an aux1 device, or 2 for an aux2 device.</p>"},{"location":"reference/configuration/#motor_positionsourcesxtype","title":"<code>motor_position.sources.X.type</code>","text":"<p>One of:</p> <ul> <li>0 - disabled</li> <li>1 - SPI</li> <li>2 - UART</li> <li>3 - Quadrature</li> <li>4 - Hall</li> <li>5 - Index</li> <li>6 - Sine/Cosine</li> <li>7 - I2C</li> <li>8 - Sensorless (not implemented)</li> </ul> <p>Note: The \"Index\" source type is only allowed for an output referenced encoder, and can be used as an alternate way to enter the \"output\" homed state.</p>"},{"location":"reference/configuration/#motor_positionsourcesxi2c_device","title":"<code>motor_position.sources.X.i2c_device</code>","text":"<p>If <code>type</code> was \"7/I2C\", this is a 0 based index specifying which I2C device on that port should be used.</p>"},{"location":"reference/configuration/#motor_positionsourcesxincremental_index","title":"<code>motor_position.sources.X.incremental_index</code>","text":"<p>If the specified auxiliary port has an incremental encoder, like a quadrature encoder, this can be set to either 1 or 2 in order to use an \"index\" pin to reference the data to a given position.  It will allow the source to provide theta readings for commutation.</p>"},{"location":"reference/configuration/#motor_positionsourcesxcpr","title":"<code>motor_position.sources.X.cpr</code>","text":"<p>The CPR of the given input.  In some cases this is automatically set, but in most it will need to be manually entered.</p>"},{"location":"reference/configuration/#motor_positionsourcesxoffsetsign","title":"<code>motor_position.sources.X.offset/sign</code>","text":"<p>An integer offset and inversion to apply.  The resulting value is: <code>(raw + offset) * sign / cpr</code>.</p>"},{"location":"reference/configuration/#motor_positionsourcesxreference","title":"<code>motor_position.sources.X.reference</code>","text":"<ul> <li>0 - this source is relative to the rotor</li> <li>1 - this source is relative to the output</li> </ul>"},{"location":"reference/configuration/#motor_positionsourcesxpll_filter_hz","title":"<code>motor_position.sources.X.pll_filter_hz</code>","text":"<p>Selects the 3dB cutoff frequency of a low-pass filter used on this source.  It should typically be less than 10X the update rate of the input and if used as the commutation or output sensor, should be higher than the mechanical bandwidth of the plant.  Within that range, it can be tuned for audible noise versus performance.</p> <p>If set to 0, then no filter is applied.  In that case, sensors which do not natively measure velocity will produce no velocity readings (most of them).</p>"},{"location":"reference/configuration/#motor_positioncommutation_source","title":"<code>motor_position.commutation_source</code>","text":"<p>A 0-based index into the source list that selects the source to use for commutation.  This means it should have an accurate measure of the relationship between the rotor and stator.</p> <p>It is not recommended to use quadrature sources for commutation as they can lose counts and require additional application level homing support at each power-on.</p>"},{"location":"reference/configuration/#motor_positionoutputsource","title":"<code>motor_position.output.source</code>","text":"<p>A 0-based index into the source list that selects the source to use for the output position.  The position and velocity from this source will be used for control in \"position\" mode.</p>"},{"location":"reference/configuration/#motor_positionoutputoffsetsign","title":"<code>motor_position.output.offset/sign</code>","text":"<p>The offset is a floating point value measured in output revolutions. Combined with the sign of -1/1, they can be used to position the 0 point of the output and control its direction of rotation.</p>"},{"location":"reference/configuration/#motor_positionoutputreference_source","title":"<code>motor_position.output.reference_source</code>","text":"<p>If non-negative, this is a 0-based index into the source list.  The selected source is used at power on to disambiguate the output position for multi-turn scenarios or when a reducer is configured.</p>"},{"location":"reference/configuration/#motor_positionrotor_to_output_ratio","title":"<code>motor_position.rotor_to_output_ratio</code>","text":"<p>The number of times the output turns for each revolution of the rotor. For gear reducers (almost all configurations), this will be less than one.  For example, a 4x gear reduction would be entered as 0.25.</p>"},{"location":"reference/configuration/#motor_positionrotor_to_output_override","title":"<code>motor_position.rotor_to_output_override</code>","text":"<p>If you REALLY know what you are doing, and want to configure a non-reducing ratio, this can be set to true/non-zero.  Otherwise, a ratio of greater than 1.0 will cause a fault.  This should only be used if the system has a gearbox which is not a reducer, but speeds up the output.</p>"},{"location":"reference/encoders/","title":"Encoder Configuration Reference","text":"<p>This page contains detailed technical reference for advanced encoder configuration.</p>"},{"location":"reference/encoders/#overview","title":"Overview","text":"<p>moteus includes an onboard on-axis magnetic encoder and supports a number of options for using external encoders.  To understand how to use them, we first need to know the two things that moteus needs encoders for:</p> <ul> <li>Commutation: moteus needs to know the electrical relationship   between the stator and the rotor in order to apply torque.</li> <li>Output: moteus needs to know the position and velocity of the   output shaft in order to follow commanded trajectories.</li> </ul> <p>By default, the onboard magnetic encoder (AS5047P) is assumed to sense the rotor.  It is also used as the source for position and velocity of the output constrained by a configurable reduction ratio.</p> <p>Configuration is performed in 3 stages: first is the auxiliary port configuration, second is encoder source configuration, and finally is the output configuration.</p> <p></p>"},{"location":"reference/encoders/#supported-encoders","title":"Supported Encoders","text":"<p>The following encoders are currently supported by moteus:</p> Name Interface Method Performance Mounting Price Onboard AS5047P SPI (integrated) +++ on-axis Included AS5047x SPI +++ on-axis $ AS5048B I2C ++ on-axis $ AS5600 I2C + on-axis $ AksIM-2 RS422 w/ 5V +++++ off-axis $$$ CUI AMT21x RS422 w/ 5V ++++ shaft $$ CUI AMT22x SPI w/ 5V ++++ shaft $$ MA600 SPI ++++ on/off-axis $ MA732 SPI +++ on/off-axis $ iC-PZ SPI w/ 5V +++++ off-axis $$$ Quadrature Quadrature variable x x Sine/Cosine Sine/Cosine + x x Hall effect Hall effect x $"},{"location":"reference/encoders/#auxiliary-port","title":"Auxiliary Port","text":"<p>There are two auxiliary ports on moteus, each with pins that can be used for various functions.</p> <p>They can provide power to external devices in addition to I/O pins:</p> 3V 5V 12V moteus-r4.5 50mA N/A N/A moteus-r4.8-4.11 100mA N/A N/A moteus-c1 50mA 100mA N/A moteus-n1 100mA 200mA N/A moteus-x1 100mA 200mA 150mA"},{"location":"reference/encoders/#io-pin-capabilities","title":"I/O Pin capabilities","text":"<ul> <li>Con: The pin number on the connector</li> <li>Aux: The number used to configure the pin in <code>aux?.pins.X</code></li> <li>SPI: Serial peripheral interface support</li> <li>ADC/Sin/Cos: Supports analog input, and sine/cosine input</li> <li>I2C: Inter-integrated circuit protocol</li> <li>HW Quad/PWM: Supports \"hardware\" quadrature input and PWM output</li> </ul>"},{"location":"reference/encoders/#r411-pins-aux1enc","title":"r4.11 Pins (AUX1/ENC)","text":"moteus r4.5/8/11 Con Aux SPI ADC/Sin/Cos I2C HW Quad/PWM UART 5VT 3.3V  (3) 1 C 2 0 X X GND (G) 3 K 4 1 CLK X I 5 2 MISO X O 6 3 MOSI X"},{"location":"reference/encoders/#r411-pins-aux2abs","title":"r4.11 Pins (AUX2/ABS)","text":"moteus r4.5/8/11 Con Aux SPI ADC/Sin/Cos I2C HW Quad/PWM UART 5VT 3.3V (3) 1 2 0 SCL RX X 3 1 SDA TX X GND (G) 4 DBG 1 2 X DBG 2 3 X <p>Note: For moteus r4.5/8/11, DBG 1/2 are not present on the ABS connector, but are exposed pads on the circuit board.</p>"},{"location":"reference/encoders/#c1-pins","title":"c1 Pins","text":"<p>The moteus-c1 has limited AUX1 port availability. Only pins D and E from AUX1 are exposed on an unpopulated 0.05\" through-hole land pattern. I2C pullups are not available on moteus-c1 for aux1.</p> moteus c1 Con AUX SPI ADC/Sin/Cos I2C HW Quad/PWM UART 5VT D 3 SCL 2.1 RX X E 4 SDA 2.2 TX X"},{"location":"reference/encoders/#n1x1-pins-aux1enc","title":"n1/x1 Pins (AUX1/ENC)","text":"moteus n1/x1 Con AUX SPI ADC/Sin/Cos I2C HW Quad/PWM UART 5VT 5V (5) 1 3.3V (3) 2 A 3 0 CLK X B * 4 1 MISO 3.1 RX C 5 2 MOSI X 3.2 D 6 3 SCL 2.1 RX X E 7 4 SDA 2.2 TX X GND (G) 8 <p>Note: For moteus n1, the B pin software configured pullup cannot be used effectively. Thus the B pin is unsuitable for open-drain inputs like hall effect sensors unless external pullups are provided.</p> <p>Note: The moteus n1 and x1 have a hardware RS422 transceiver connected to aux1's pins D and E which can be enabled through configuration. RS485 devices like the CUI AMT21x can be used if the RS422 pin Y is connected to A and RS422 pin Z is connected to B.</p>"},{"location":"reference/encoders/#c1n1x1-pins-aux2abs","title":"c1/n1/x1 Pins (AUX2/ABS)","text":"moteus n1/x1 Con AUX SPI ADC/Sin/Cos I2C HW Quad/PWM UART 5VT 5V (5) 1 3.3V (3) 2 A 3 0 CLK X X B 4 1 MISO X SDA RX X C 5 2 MOSI X SCL 4.1 TX X D 6 3 4.2 RX X GND (G) 7"},{"location":"reference/encoders/#pin-capabilities","title":"Pin Capabilities","text":"<p>The following capabilities can be used.  Some are supported on any pins, others only on select pins.</p>"},{"location":"reference/encoders/#software-quadrature-input","title":"Software Quadrature Input","text":"<p>Pins: any</p> <p>The software quadrature feature uses GPIO pins to read incremental quadrature encoders.  It is capable of counting at 200,000 counts per second without error, but incurs processor overhead that increases with count rate.  Higher overhead means the latency to respond to CAN messages increases.</p>"},{"location":"reference/encoders/#hall-sensor","title":"Hall sensor","text":"<p>Pins: any</p> <p>3 hall sensor inputs are required.  For many hall sensors, the pullup must be configured for the auxiliary port pin in question.</p> <p>When using hall effect sensors as the commutation source, calibration with moteus_tool requires the <code>--cal-hall</code> option be passed.</p>"},{"location":"reference/encoders/#index","title":"Index","text":"<p>Pins: any</p> <p>This is a single pin that is high when the encoder is in a known location.  It can be fed from the \"I\" signal of an ABI output, or a dedicated homing sensor.</p>"},{"location":"reference/encoders/#gpio-input","title":"GPIO Input","text":"<p>Pins: any</p> <p>Any pin may be designated as a GPIO input.  Its value may be read over the diagnostic or register protocols.</p>"},{"location":"reference/encoders/#i2c-master","title":"I2C Master","text":"<p>Pins: select</p> <p>Between 1 and 3 I2C devices may be periodically polled at rates up to 200Hz.  The associated pins on moteus r4.5/8/11 have permanently configured 2kohm pullup resistors.</p>"},{"location":"reference/encoders/#spi-master","title":"SPI Master","text":"<p>Pins: select</p> <p>A variety of SPI based peripherals are supported.  This mode is also used for the onboard encoder, which when enabled, claims the CLK, MOSI, and MISO pins on auxiliary port 1.</p>"},{"location":"reference/encoders/#hardware-quadrature-input","title":"Hardware Quadrature Input","text":"<p>Pins: select</p> <p>Hardware quadrature pins use microcontroller peripherals to process quadrature input at any speed with no processor overhead.</p>"},{"location":"reference/encoders/#sinecosine","title":"Sine/cosine","text":"<p>Pins: select</p> <p>Analog sine/cosine inputs are supported with a configurable common mode voltage.</p>"},{"location":"reference/encoders/#analog-input","title":"Analog input","text":"<p>Pins: select</p> <p>Arbitary analog inputs can be read either over the diagnostic or register protocol.</p>"},{"location":"reference/encoders/#uart","title":"UART","text":"<p>Pins: select</p> <p>A variety of asynchronous serial encoders and debugging facilities are supported.</p> <p>The moteus-n1 and moteus-x1 additionally have a hardware RS422 transceiver connected to aux1's pins D and E which can be enabled through configuration.  RS485 devices like the CUI AMT21x can be used if the RS422 pin Y is connected to A and RS422 pin Z is connected to B.</p>"},{"location":"reference/encoders/#pin-configuration","title":"Pin Configuration","text":"<p>Auxiliary port configuration is achieved in two steps.  First, the <code>aux[12].pins.X.mode</code> value is set to the proper capability for each pin.  <code>aux[12].pins.X.pull</code> can be used to configure an optional pullup or pulldown for some modes.  Second, the corresponding capabilities must be configured in one of the capability specific sections of <code>aux[12]</code>.  For instance, for each auxiliary port, the SPI configuration in <code>aux[12].spi</code> has a <code>mode</code> to select what the slave device is and a <code>rate_hz</code> to define the frequency of the SPI peripheral.</p> <p>For I2C ports, up to 3 different slave devices may be configured, in each of <code>aux[12].i2c.devices.[012]</code>.</p> <p>The diagnostic values in <code>aux[12]</code> can be used to monitor for errors from mis-configuration or mis-operation.</p>"},{"location":"reference/encoders/#source-configuration","title":"Source Configuration","text":"<p>Once the auxiliary ports have been configured, next encoder sources should be configured in <code>motor_position.sources</code>.  Up to 3 sources may be configured, with the available types roughly corresponding to the categories available from the auxiliary ports.  Typically, source 0 is used for the sensor that is used for commutation.</p> <p>For each source <code>motor_position.sources.[012].aux_number</code> should be either \"1\" or \"2\", to select which auxiliary port the sensor should be read from.  <code>motor_position.sources.[012].type</code> selects the type of sensor.  For I2C based sources, <code>motor_position.sources.[012].i2c_device</code> selects which I2C device on that auxiliary port is used.</p> <p>For sources that are incremental only, like quadrature, a source level index may be configured in <code>motor_position.sources.[012].incremental_index</code>.  This should be used if the incremental source is needed to provide position for commutation.</p> <p>Each source can be marked as measuring the rotor or the output in <code>motor_position.sources.[012].reference</code>.</p> <p>Each source has configuration that determines how to map the raw value provided by the device into a rotary angle.  <code>cpr</code> is the number of counts per revolution, <code>offset</code> provides an integral count offset, and <code>sign</code> can be used to invert the reading.  The final reading is <code>(raw + offset) * sign / cpr</code>.</p> <p>Finally, each source has a configurable low pass filter, with cutoff frequency set by <code>motor_position.sources.[012].pll_filter_hz</code>.  It may be set to 0 to disable the filter.  If disabled no velocity will be interpolated on sensors that do not provide it natively.</p>"},{"location":"reference/encoders/#output-configuration","title":"Output Configuration","text":"<p>The third major stage controls how the sources are used by the motor controller.  Some source selections may be left at -1, which disables that feature.</p> <p><code>motor_position.commutation_source</code> selects which source is used to provide rotor position for commutation purposes.  It is typically left at source 0 and is required.  Note, quadrature sources are not recommended for commutation as they can lose counts and require additional application level homing support on each power-on.</p> <p><code>motor_position.output.source</code> selects which source is used to provide output position and velocity and is required.</p> <p><code>motor_position.output.offset</code> and <code>motor_position.output.sign</code> are used to transform the output position to achieve a given zero point and rotational direction.</p> <p><code>motor_position.output.reference_source</code> optionally configures a source that is used solely to disambiguate the output position at startup.  It could be a low-rate I2C based sensor for instance, or an index source configured from a homing switch.</p> <p>Finally, <code>motor_position.rotor_to_output_ratio</code> defines the number of turns of the output for one turn of the rotor.  This is used to map the readings from sensors that are defined relative to one into the other.  For gear reducers (almost all configurations), this will be less than one.  For example, a 4x gear reduction would be entered as 0.25.</p>"},{"location":"reference/firmware/","title":"Flashing and building firmware","text":"<p>moteus controllers have both upgradeable firmware and a permissively licensed source code for the firmware.  This section describes how to flash new (or old) versions of the firmware, and how to build it from source.</p>"},{"location":"reference/firmware/#flashing-over-can","title":"Flashing over CAN","text":"<p>The latest firmware can be downloaded from: https://github.com/mjbots/moteus/releases</p> <p>You need the file named YYYYMMDD-moteus-HASH.elf NOT the one named \"bootloader\".</p> <p>Download that file and save it somewhere on your computer, then substitute its path in place of <code>path/to/file.elf</code> in the following command.</p> <pre><code>python3 -m moteus.moteus_tool --target 1 --flash path/to/file.elf\n</code></pre>"},{"location":"reference/firmware/#building-firmware","title":"Building firmware","text":"<p>To build the moteus firmware, an x86-64 Ubuntu 20.04, 22.04, or 24.04 system is required.</p> <pre><code>tools/bazel build --config=target //:target\n</code></pre>"},{"location":"reference/firmware/#flash-from-the-swd-port","title":"Flash from the SWD port","text":"<p>If CAN-FD is inoperative, then new firmware can be flashed using the SWD connector on each moteus.  First install dependencies:</p> <pre><code>sudo apt install openocd binutils-arm-none-eabi\n</code></pre> <p>Then attach a stm32 programmer to the USB port on your computer and the SWD port on the moteus.</p> <p>The firmware can be built and flashed using:</p> <pre><code>tools/bazel build --config=target //fw:flash\n</code></pre> <p>Or, if already built, flashed using:</p> <pre><code>./fw/flash.py\n</code></pre> <p>The python script can be used to flash pre-compiled images as well:</p> <pre><code>./fw/flash.py path/to/firmware.elf path/to/bootloader.elf\n</code></pre>"},{"location":"reference/firmware/#debug-from-the-swd-port","title":"Debug from the SWD port","text":"<p>gdb can be used for debugging the firmware when an stm32 programmer is attached to the SWD port.  First, install dependencies:</p> <pre><code>sudo apt install gdb-multiarch\n</code></pre> <p>Then, in one terminal run:</p> <pre><code>./run_openocd_noreset.sh\n</code></pre> <p>In another terminal run:</p> <pre><code>gdb-multiarch -x moteus-debug.gdb bazel-out/stm32g4-opt/bin/moteus.elf\n</code></pre> <p>Debugging hints:</p> <ul> <li>Flashing Red Light: This means a debug assertion failed.  Using <code>bt</code> to get a backtrace will tell you the call site.</li> <li>Pool Size: The firmware allocates data from a fixed size pool during initialization.  If new structures are added, this size can be exceeded.  Either reduce the size of structures, or increase the size of the pool.</li> <li>Optimizations: The moteus firmware must have optimizations enabled globally.  This makes debugging challenging.  Some strategies:</li> <li>Expose data you need to structures available to tview</li> <li>Single step through assembly</li> <li>Use the <code>__attribute__((optimize(\"O0\")))</code> on individual functions to disable optimization</li> </ul>"},{"location":"reference/hardware/","title":"Hardware Specifications","text":""},{"location":"reference/hardware/#cad-and-models","title":"CAD and Models","text":"Name 2D CAD 3D Model moteus-c1 2D CAD STEP moteus-r4 2D CAD STEP moteus-x1 2D CAD STEP moteus-n1 2D CAD STEP"},{"location":"reference/hardware/#electrical-limits","title":"Electrical Limits","text":"Name Min Voltage Nominal Abs Max Voltage Peak Output 3V Aux 5V Aux 12V Aux moteus-c1 10V 24V 51V (&lt;= 12S) 20A 50mA 100mA N/A moteus-r4 10V 24V 44V (&lt;= 10S) 100A 100mA N/A N/A moteus-x1 10V 24V 54V (&lt;= 12S) 120A 100mA 200mA 150mA moteus-n1 10V 24V 54V (&lt;= 12S) 100A 100mA 200mA N/A"},{"location":"reference/hardware/#power-limits","title":"Power Limits","text":"<p>The allowable maximum power for each moteus controller depends upon the input voltage and PWM switching frequency.  The below table gives the maximum allowable power at <code>servo.pwm_rate_hz=30000</code>.</p> Name Peak power High input power moteus-r4 &lt;= 30V 900W linear derated &gt;= 38V 400W moteus-c1 &lt;= 28V 250W linear derated &gt;= 41V 150W moteus-n1 &lt;= 36V 2000W linear derated &gt;= 44V 1000W <p>For other values of <code>servo.pwm_rate_hz</code>, the allowable maximum power changes linearly with the PWM rate, so that at 15000, the maximum power is half of that in the above table and at 60000 it is double that.  Note however, that efficiency of the controller goes down significantly at higher PWM rates.</p> <p>The current power limit is reported in <code>servo_stats.max_power_W</code>.  The controller will attempt to limit output phase current so as to stay within this reported power limit in either direction, i.e. applying power or regenerating energy.</p>"},{"location":"reference/limits/","title":"Application Limits","text":""},{"location":"reference/limits/#position","title":"Position","text":"<p>The reported and commanded position is limited to +-32768.0 revolutions</p> <p>If either:</p> <p>a. the position is commanded as the special value (NaN or maximally negative), or b. the kp term is zero either through configuration or the \"kp scale\"</p> <p>Then it is safe for the controller to \"wrap around\" from the maximal possible position to the maximally negative position and vice versa. This is useful in velocity control applications.</p> <p>The reported and commanded position is internally treated as a 32 bit floating point value when received as a command or reported to a client.  Thus the position resolution is reduced when the magnitude of the position is large.  Resolution equal to the full capabilities of the onboard encoder (~0.09degree) is maintained to positions of +-2048.0 revolutions.  At the maximum possible position, this resolution is reduced to ~1.44degrees.  Note, that this is only for values received from or reported to clients.  Internally, control and PID feedback on the position works in an integral space and performs identically throughout the available control envelope.</p>"},{"location":"reference/limits/#velocity","title":"Velocity","text":"<p>The smallest usable mechanical velocity which can be commanded is 0.0001 revolutions per second.  This corresponds to 0.036 degrees per second.</p> <p>The maximum mechanical velocity which can be commanded is 28000 rpm, or ~467 revolutions per second before any reducers.  Note, most motors will be incapable of this speed either mechanically or electrically.</p> <p>The maximum electrical frequency is 4kHz.</p>"},{"location":"reference/pinouts/","title":"Pinouts","text":""},{"location":"reference/pinouts/#moteus-c1","title":"moteus-c1","text":""},{"location":"reference/pinouts/#moteus-r4","title":"moteus-r4","text":""},{"location":"reference/pinouts/#moteus-x1","title":"moteus-x1","text":""},{"location":"reference/pinouts/#moteus-n1","title":"moteus-n1","text":""},{"location":"reference/pinouts/#additional-information","title":"Additional Information","text":""},{"location":"reference/pinouts/#can-termination","title":"CAN Termination","text":"<p>CAN connections should be terminated by a 120 ohm resistor at both ends of a bus.  Some mjbots products have built in termination resistors, such as the pi3hat.  The mjcanfd-usb-1x and fdcanusb have a software configurable termination resistor that is by default on. moteus controllers have no termination resistors.  For very short runs, the system will work terminated only on one side.  However, when runs become longer than 0.5m, you will likely need to terminate both ends.  This can be done by crimping a 120 ohm resistor into a JST PH3 connector and connecting it to the open data connector or by purchasing a CAN terminator.</p>"},{"location":"reference/pinouts/#recommended-mating-hardware","title":"Recommended Mating Hardware","text":"Connector Mate P/N Terminal P/N Pre-crimped Wire JST PH-3 PHR-3 SPH-002T-P0.5L 10cm, 30cm, 50cm PH3 JST GH-6 GHR-06V-S SSHL-002T-P0.2 28 AWG 20cm JST GH-7 GHR-07V-S SSHL-002T-P0.2 28 AWG 20cm JST GH-8 GHR-08V-S SSHL-002T-P0.2 28 AWG 20cm JST ZH-4 ZHR-4 SZH-002T-P0.5 JST ZH-6 ZHR-6 SZH-002T-P0.5 stm32 programmer AMass XT30 XT30U-F"},{"location":"reference/pinouts/#recommended-low-cost-manual-crimp-tools","title":"Recommended Low Cost Manual Crimp Tools","text":"<ul> <li>JST PH: TU-190-08</li> <li>JST ZH: PEBA 1020M</li> <li>JST GH: PEBA 1020M</li> </ul>"},{"location":"reference/pinouts/#moteus-r4-pico-spox-6-enc","title":"moteus-r4 - Pico-SPOX 6 ENC","text":"<p>The ENC/AUX1 connector on moteus-r4 are intended to be populated with a Molex Pico-SPOX 6 connector PN 0874380643, or as an alternate, TE 5-1775444-6.</p>"},{"location":"reference/python/","title":"Python API reference","text":""},{"location":"reference/python/#moteuscontroller","title":"moteus.Controller","text":"<p>Operates a single moteus controller across some communication medium.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <p>bus ID of the controller or DeviceAddress structure</p> <code>1</code> <code>query_resolution</code> <p>an instance of moteus.QueryResolution</p> <code>QueryResolution()</code> <code>position_resolution</code> <p>an instance of moteus.PositionResolution</p> <code>PositionResolution()</code> <code>transport</code> <p>something modeling moteus.Transport to send commands through</p> <code>None</code>"},{"location":"reference/python/#moteus.Controller.set_position","title":"<code>set_position(*args, **kwargs)</code>  <code>async</code>","text":""},{"location":"reference/python/#moteus.Controller.make_position","title":"<code>make_position(*, position=None, velocity=None, feedforward_torque=None, kp_scale=None, kd_scale=None, maximum_torque=None, stop_position=None, watchdog_timeout=None, velocity_limit=None, accel_limit=None, fixed_voltage_override=None, ilimit_scale=None, fixed_current_override=None, ignore_position_bounds=None, query=False, query_override=None)</code>","text":"<p>Return a moteus.Command structure with data necessary to send a position mode command with the given values.</p>"},{"location":"reference/python/#moteus.Controller.set_position_wait_complete","title":"<code>set_position_wait_complete(period_s=0.025, query_override=None, *args, **kwargs)</code>  <code>async</code>","text":"<p>Repeatedly send a position mode command to a device until it reports that the trajectory has been completed.</p> <p>If the controller is unresponsive, this method will never return.</p> <p>If the controller reports a fault or position mode timeout, a FaultError exception will be raised.</p>"},{"location":"reference/python/#moteus.Controller.set_stop","title":"<code>set_stop(*args, **kwargs)</code>  <code>async</code>","text":""},{"location":"reference/python/#moteus.Controller.make_stop","title":"<code>make_stop(*, query=False, query_override=None)</code>","text":"<p>Return a moteus.Command structure with data necessary to send a stop mode command.</p>"},{"location":"reference/python/#moteus.Controller.query","title":"<code>query(**kwargs)</code>  <code>async</code>","text":""},{"location":"reference/python/#moteus.Controller.make_query","title":"<code>make_query(query_override=None)</code>","text":""},{"location":"reference/python/#moteus.Controller.custom_query","title":"<code>custom_query(*args, **kwargs)</code>  <code>async</code>","text":""},{"location":"reference/python/#moteus.Controller.make_custom_query","title":"<code>make_custom_query(to_query_fields)</code>","text":"<p>Return a moteus.Command structure with data required to query the registers given by the 'to_query_fields' dictionary of registers to resolutions.</p>"},{"location":"reference/python/#moteus.Controller.set_output_nearest","title":"<code>set_output_nearest(*args, **kwargs)</code>  <code>async</code>","text":""},{"location":"reference/python/#moteus.Controller.make_set_output_nearest","title":"<code>make_set_output_nearest(*args, position=0.0, query=False, query_override=None)</code>","text":""},{"location":"reference/python/#moteus.Controller.set_output_exact","title":"<code>set_output_exact(*args, **kwargs)</code>  <code>async</code>","text":""},{"location":"reference/python/#moteus.Controller.make_set_output_exact","title":"<code>make_set_output_exact(*args, position=0.0, query=False, query_override=None)</code>","text":""},{"location":"reference/python/#moteus.Controller.set_recapture_position_velocity","title":"<code>set_recapture_position_velocity(query=False, query_override=None)</code>  <code>async</code>","text":""},{"location":"reference/python/#moteus.Controller.make_recapture_position_velocity","title":"<code>make_recapture_position_velocity(query=False, query_override=None)</code>","text":""},{"location":"reference/python/#moteus.Controller.set_vfoc","title":"<code>set_vfoc(*args, **kwargs)</code>  <code>async</code>","text":""},{"location":"reference/python/#moteus.Controller.make_vfoc","title":"<code>make_vfoc(*, theta, voltage, theta_rate=0.0, query=False, query_override=None)</code>","text":"<p>Return a moteus.Command structure with data necessary to send a voltage mode FOC command.</p>"},{"location":"reference/python/#moteus.Controller.set_current","title":"<code>set_current(*args, **kwargs)</code>  <code>async</code>","text":""},{"location":"reference/python/#moteus.Controller.make_current","title":"<code>make_current(*, d_A, q_A, query=False, query_override=None)</code>","text":"<p>Return a moteus.Command structure with data necessary to send a current mode command.</p>"},{"location":"reference/python/#moteus.Controller.set_stay_within","title":"<code>set_stay_within(*args, **kwargs)</code>  <code>async</code>","text":""},{"location":"reference/python/#moteus.Controller.make_stay_within","title":"<code>make_stay_within(*, lower_bound=None, upper_bound=None, feedforward_torque=None, kp_scale=None, kd_scale=None, maximum_torque=None, stop_position=None, watchdog_timeout=None, ilimit_scale=None, ignore_position_bounds=None, query=False, query_override=None)</code>","text":"<p>Return a moteus.Command structure with data necessary to send a within mode command with the given values.</p>"},{"location":"reference/python/#moteus.Controller.set_brake","title":"<code>set_brake(*args, **kwargs)</code>  <code>async</code>","text":""},{"location":"reference/python/#moteus.Controller.make_brake","title":"<code>make_brake(*, query=False, query_override=None)</code>","text":""},{"location":"reference/python/#moteus.Controller.set_write_gpio","title":"<code>set_write_gpio(*args, **kwargs)</code>  <code>async</code>","text":""},{"location":"reference/python/#moteus.Controller.make_write_gpio","title":"<code>make_write_gpio(aux1=None, aux2=None, query=False, query_override=None)</code>","text":"<p>Return a moteus.Command structure with data necessary to set one or more GPIO registers.</p> <p>aux1/aux2 are an optional integer bitfield, where the least significant bit is pin 0 on the respective port.</p>"},{"location":"reference/python/#moteus.Controller.read_gpio","title":"<code>read_gpio()</code>  <code>async</code>","text":"<p>Return a bytes() object with an int8 for each auxiliary port.  The pins for each port are represented as bits, with the least significant bit being pin 0.</p> <p>None can be returned if no response is received.</p>"},{"location":"reference/python/#moteus.Controller.set_trim","title":"<code>set_trim(*args, **kwargs)</code>  <code>async</code>","text":""},{"location":"reference/python/#moteus.Controller.make_set_trim","title":"<code>make_set_trim(*, trim=0)</code>","text":""},{"location":"reference/python/#moteus.Controller.set_aux_pwm","title":"<code>set_aux_pwm(*args, **kwargs)</code>  <code>async</code>","text":""},{"location":"reference/python/#moteus.Controller.make_aux_pwm","title":"<code>make_aux_pwm(*, aux1_pwm1=None, aux1_pwm2=None, aux1_pwm3=None, aux1_pwm4=None, aux1_pwm5=None, aux2_pwm1=None, aux2_pwm2=None, aux2_pwm3=None, aux2_pwm4=None, aux2_pwm5=None, query=False, query_override=None)</code>","text":""},{"location":"reference/python/#moteusmake_transport_args","title":"moteus.make_transport_args","text":"<p>Add transport specific arguments to an argparse.ArgumentParser</p> <p>Parameters:</p> Name Type Description Default <code>parser</code> <p>the argparse.ArgumentParser instance</p> required"},{"location":"reference/python/#moteusget_singleton_transport","title":"moteus.get_singleton_transport","text":"<p>Return (and construct if necessary) a transport.Transport instance that uses either all available CAN-FD interfaces on the system, or those configured by args.</p> <p>Parameters:</p> Name Type Description Default <code>args</code> <p>an argparse.Namespace object</p> <code>None</code> <p>Returns:</p> Type Description <p>a moteus.Transport object</p>"},{"location":"reference/python/#moteusqueryresolution","title":"moteus.QueryResolution","text":"<p>Specify which registers should be requested, and with which resolution, during query operations.</p>"},{"location":"reference/python/#moteus.QueryResolution.mode","title":"<code>mode = mp.INT8</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/python/#moteus.QueryResolution.position","title":"<code>position = mp.F32</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/python/#moteus.QueryResolution.velocity","title":"<code>velocity = mp.F32</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/python/#moteus.QueryResolution.torque","title":"<code>torque = mp.F32</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/python/#moteus.QueryResolution.q_current","title":"<code>q_current = mp.IGNORE</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/python/#moteus.QueryResolution.d_current","title":"<code>d_current = mp.IGNORE</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/python/#moteus.QueryResolution.abs_position","title":"<code>abs_position = mp.IGNORE</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/python/#moteus.QueryResolution.power","title":"<code>power = mp.IGNORE</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/python/#moteus.QueryResolution.motor_temperature","title":"<code>motor_temperature = mp.IGNORE</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/python/#moteus.QueryResolution.trajectory_complete","title":"<code>trajectory_complete = mp.IGNORE</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/python/#moteus.QueryResolution.rezero_state","title":"<code>rezero_state = mp.IGNORE</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/python/#moteus.QueryResolution.home_state","title":"<code>home_state = mp.IGNORE</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/python/#moteus.QueryResolution.voltage","title":"<code>voltage = mp.INT8</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/python/#moteus.QueryResolution.temperature","title":"<code>temperature = mp.INT8</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/python/#moteus.QueryResolution.fault","title":"<code>fault = mp.INT8</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/python/#moteus.QueryResolution.aux1_gpio","title":"<code>aux1_gpio = mp.IGNORE</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/python/#moteus.QueryResolution.aux2_gpio","title":"<code>aux2_gpio = mp.IGNORE</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/python/#moteuspositionresolution","title":"moteus.PositionResolution","text":"<p>Specify what resolutions should be used for each register when sending position mode commands.</p>"},{"location":"reference/python/#moteus.PositionResolution.position","title":"<code>position = mp.F32</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/python/#moteus.PositionResolution.velocity","title":"<code>velocity = mp.F32</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/python/#moteus.PositionResolution.feedforward_torque","title":"<code>feedforward_torque = mp.F32</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/python/#moteus.PositionResolution.kp_scale","title":"<code>kp_scale = mp.F32</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/python/#moteus.PositionResolution.kd_scale","title":"<code>kd_scale = mp.F32</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/python/#moteus.PositionResolution.maximum_torque","title":"<code>maximum_torque = mp.F32</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/python/#moteus.PositionResolution.stop_position","title":"<code>stop_position = mp.F32</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/python/#moteus.PositionResolution.watchdog_timeout","title":"<code>watchdog_timeout = mp.F32</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/python/#moteus.PositionResolution.velocity_limit","title":"<code>velocity_limit = mp.F32</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/python/#moteus.PositionResolution.accel_limit","title":"<code>accel_limit = mp.F32</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/python/#moteus.PositionResolution.fixed_voltage_override","title":"<code>fixed_voltage_override = mp.F32</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/python/#moteus.PositionResolution.ilimit_scale","title":"<code>ilimit_scale = mp.F32</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/python/#moteus.PositionResolution.fixed_current_override","title":"<code>fixed_current_override = mp.F32</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/python/#moteus.PositionResolution.ignore_position_bounds","title":"<code>ignore_position_bounds = mp.F32</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"reference/python/#moteusstream","title":"moteus.Stream","text":"<p>Presents a python file-like interface to the diagnostic stream of a moteus controller.</p> <p>Parameters:</p> Name Type Description Default <code>controller</code> <p>moteus.Controller instance</p> required <code>channel</code> <p>diagnostic channel to use</p> <code>1</code> <code>verbose</code> <p>if True, all communication written to stdout</p> <code>False</code>"},{"location":"reference/python/#moteus.Stream.command","title":"<code>command(data, allow_any_response=False)</code>  <code>async</code>","text":""},{"location":"reference/python/#moteus.Stream.write_message","title":"<code>write_message(data)</code>  <code>async</code>","text":""},{"location":"reference/python/#moteus.Stream.read_data","title":"<code>read_data(name)</code>  <code>async</code>","text":""},{"location":"reference/python/#moteustransport","title":"moteus.Transport","text":"<p>This is an object which can dispatch commands to one or more controllers across potentially multiple CAN-FD busses.</p>"},{"location":"reference/python/#moteus.Transport.cycle","title":"<code>cycle(commands, request_attitude=False, read_unsolicited=None, force_can_check=None)</code>  <code>async</code>","text":"<p>Issue all commands, returning any resulting frames.</p> <p>Parameters:</p> Name Type Description Default <code>request_attitude</code> <p>This is present to allow producing IMU data in the same SPI cycle as CAN data with an mjbots pi3hat.</p> <code>False</code> <code>read_unsolicited</code> <p>An optional list of TransportDevices, for which any available unsolicited CAN frames should be returned.  If specified on a TransportDevice where moteus controllers are commanded, this may result in duplicate frame receipts.</p> <code>None</code> <code>force_can_check</code> <p>A bitfield to force a connected pi3hat to check specific CAN ports.  Modern code should instead use the read_unsolicited kwargs.</p> <code>None</code>"},{"location":"reference/python/#moteus.Transport.read","title":"<code>read(channel=None)</code>  <code>async</code>","text":"<p>Wait for one or more frames to be received.</p> <p>This can be used to receive unsolicited data.</p> <p>Parameters:</p> Name Type Description Default <code>channel</code> <p>If specified, only read from the given TransportDevice.</p> <code>None</code>"},{"location":"reference/python/#moteus.Transport.discover","title":"<code>discover(can_prefix=0, source=0, timeout=0.2)</code>  <code>async</code>","text":"<p>Discover all controllers attached to any included TransportDevices which support discovery.</p> <p>Returns:</p> Type Description <code>list[DeviceInfo]</code> <p>A list of DeviceInfo structures containing the CAN ID, UUID, and TransportDevice where the device is located.</p>"},{"location":"reference/python/#moteus.Transport.flush_read_queue","title":"<code>flush_read_queue(timeout=0.1, channel=None)</code>  <code>async</code>","text":"<p>Flush any pending receive frames.</p> <p>Parameters:</p> Name Type Description Default <code>timeout</code> <p>Time in seconds to keep reading before giving up.</p> <code>0.1</code> <code>channel</code> <p>None = all channels</p> <code>None</code>"},{"location":"reference/python/#moteus.Transport.devices","title":"<code>devices()</code>","text":"<p>Returns:</p> Type Description <code>list[TransportDevice]</code> <p>list of TransportDevices in this Transport</p>"},{"location":"reference/python/#moteus.Transport.count","title":"<code>count()</code>","text":"<p>Returns:</p> Type Description <code>int</code> <p>integer number of TransportDevices in this Transport</p>"},{"location":"reference/python/#moteus.Transport.close","title":"<code>close()</code>","text":"<p>Close all TransportDevices associated with this Transport.</p>"},{"location":"reference/python/#moteusfdcanusbdevice","title":"moteus.FdcanusbDevice","text":"<p>               Bases: <code>TransportDevice</code></p> <p>Connects to a single mjbots fdcanusb.</p>"},{"location":"reference/python/#moteus.FdcanusbDevice.detect_fdcanusbs","title":"<code>detect_fdcanusbs()</code>  <code>staticmethod</code>","text":"<p>Returns:</p> Type Description <code>list[str]</code> <p>list of filesystem paths that can be used to construct FdcanusbDevice objects</p>"},{"location":"reference/python/#moteuspythoncandevice","title":"moteus.PythonCanDevice","text":"<p>               Bases: <code>TransportDevice</code></p> <p>Implements a 'Transport' on top of python-can.</p>"},{"location":"reference/python/#moteus.PythonCanDevice.enumerate_devices","title":"<code>enumerate_devices(**kwargs)</code>  <code>staticmethod</code>","text":"<p>Returns:</p> Type Description <code>list[PythonCanDevice]</code> <p>list of objects for devices present in the current system</p>"},{"location":"reference/theory/","title":"Theory of Operation","text":"<p>The moteus controller is intended to drive 3 phase brushless motors using field oriented control.  It has an integrated magnetic encoder for sensing the rotor position, 3 half-H bridges for switching power to each of the three phases, and current sense capability on each of the three phases.</p> <p>The primary control mode, labeled as \"position\" mode in the rest of this document is a two stage cascaded controller, with both running at the switching frequency (by default 30kHz).</p> <p>The outermost stage is an optional limited acceleration and velocity trajectory planner.  Within that is an integrated position/velocity PID controller with optional feedforward torque.  The output of that loop is a desired torque/current for the Q phase of the FOC controller.</p> <p>The inner stage is a current mode PI controller.  Its output is the desired voltage value for the Q phase.  Then the magnetic encoder is used to map the D/Q phase voltage values to the 3 phases of the motor.</p> <p></p> <p>More precisely, the \"Position Controller\" implements the following control law:</p> <pre><code>acceleration = trajectory_follower(command_position, command_velocity)\ncontrol_velocity = command_velocity OR control_velocity + acceleration * dt OR 0.0\ncontrol_position = command_position OR control_position + control_velocity * dt\nposition_error = control_position - feedback_position\nvelocity_error = control_velocity - feedback_velocity\nposition_integrator = limit(position_integrator + ki * position_error * dt, ilimit)\ntorque = position_integrator +\n         kp * kp_scale * position_error +\n         kd * kd_scale * velocity_error +\n         command_torque\n</code></pre> <p>And the \"Current Controller\" implements the following control law:</p> <pre><code>current_error = command_current - feedback_current\ncurrent_integrator = limit(current_integrator + ki * current_error, ilimit)\nvoltage = current_integrator + kp * current_error\n</code></pre> <p>Since PID scaling for the position mode loop can be adjusted on a cycle-by-cycle basis with the <code>kp_scale</code> and <code>kd_scale</code> terms, this allows you to operate the controller with full position/velocity/torque control, or velocity/torque, or just torque, or any combination seamlessly throughout the control cycle.</p>"},{"location":"troubleshooting/calibration/","title":"Troubleshooting Calibration","text":"<p>When setting up a moteus controller with a new motor, you typically first run the automatic calibration sequence as documented in the reference manual. When your system is working well, that should be all that is necessary to enable moteus to perform accurate FOC based torque control of the motor. Then you can continue on with the remainder of the items in the Quick Start. What happens though when the automatic calibration doesn't work? This article describes the most common failure modes during calibration.</p> <p>Unfortunately, most calibration failures present the same final symptom, an error like:</p> <pre><code>CAL timeout\n</code></pre> <p>or</p> <pre><code>encoder not an integral multiple of phase\n</code></pre> <p>So to resolve, you typically start with the first items in this article, then work your way down to the less common ones.</p>"},{"location":"troubleshooting/calibration/#sense-magnet-issues","title":"Sense magnet issues","text":"<p>To operate properly using the onboard encoder, moteus requires that a diametrically magnetized sense magnet be rigidly affixed to the rotor, that it be centered laterally under the magnetic encoder on moteus, and that it has an appropriate air-gap. Let's look at each of those in turn.</p> <p>First, you need a diametrically magnetized magnet. This is one where the axis of magnetization is sideways, so that the north pole points out of the curved side of the disc. This is contrast to axially magnetized magnets where the axis of magnetization points out of the flat side. There are a wide variety of possible options here. Every moteus controller sold at mjbots.com includes an appropriate magnet, and mjbots.com also sells spares. There are also suppliers with higher temperature magnets, like the Radial Magnets, Inc. 9049 here at digikey. Sometimes however, you are converting an existing actuator to use moteus, and there is a sense magnet present already. The bad news is that it may or may not be usable with moteus and unless you know the specifications, it may be hard to know the optimal air gap required for it. In those cases it is often easiest to remove the existing magnet and replace it with a known quantity, especially if a reasonable air gap is hard to achieve.</p> <p>Second, the magnet must be rigidly affixed to the rotor. No slipping is permitted whatsoever. Practically, that means that adhesive will be required at each junction between the magnet and the rotor. Common adhesives used are cyanoacrylate gel (superglue), and epoxy. For instance, if a 3D printed spacer is used, the magnet must be glued to the spacer, and the spacer must be glued to the rotor. When the rotor moves, the magnet must move. Press fits can be problematic unless the fit is designed with a well specified tolerance and relying on friction between a magnet and something it is attracted to will definitely not work.</p> <p>Third, the magnet must be positioned laterally properly. This means that it needs to be centered under the magnetic encoder. For moteus-n1 and moteus-c1, that is centered under the bolt pattern. For moteus-r4, you should look at the 2D CAD to see where to position the magnet.</p> <p>The magnet also needs an appropriate air gap between the surface of the magnet and the surface of the encoder IC. For the magnets that mjbots sells, 2mm is near the optimal air gap, with a range of 1.5mm - 2.5mm being suitable. Spacing of 0.5mm - 8mm will likely work with degraded performance.</p> <p>Finally, the controller needs itself to be rigidly mounted with respect to the stator and rotor. If it is allowed to move or rotate, then the sensed angle of the rotor will not match the actual electrical angle needed for commutation, as well as degrading the quality of position control at the output.</p>"},{"location":"troubleshooting/calibration/#electrical-problems","title":"Electrical problems","text":"<p>The most common electrical problem that prevents calibration is poor or non-existent phase wire soldering. The phase wires of the motor must make a good connection to the moteus phase terminals. That means that when soldering, the joint must have reached a sufficient temperature and had sufficient flux such that the solder wicked both all around the wire, and wicked in to the phase wire terminal. Cold solder joints may show solder that does not fill the joint completely and does not form a proper fillet to the surfaces it touches or may show as visual artifacts between the wire, pad, and solder. This may result in no or an intermittent connection. A video showing what an appropriate result should look like is here:</p> <p>The next most common electrical problem is a motor that is fundamentally broken. That could be one which has shorted phases, inappropriate polarity of windings, or magnets with inappropriate polarity. These problems usually only appear with second hand motors, those of low quality, or hand-built motors. The easiest way to rule it out is to test with a known working motor.</p>"},{"location":"troubleshooting/calibration/#less-common-sense-magnet-issues","title":"Less Common Sense Magnet Issues","text":"<p>I have observed a few less common problems associated with sense magnets.</p> <p>In one case, the magnet was actually glued both to the rotor and to a stationary mounting bracket, preventing the rotor from moving at all.</p> <p>In other cases, magnets were allowed to exceed their rated operating temperature. The magnets mjbots sells as of May 2024 are rated to 80C. If the temperature approaches that point, often above 70C, then the axis of magnetization can drift. If that is an issue, then magnets can be procured with higher rated temperatures.</p> <p>Sense magnets for commutation must be rigidly affixed to the rotor, *not* to the output of a reducer, or any linkage that may have backlash. If the magnet is attached to a reducer, then the required angular accuracy can easily exceed what the onboard encoder is capable of measuring. Linkages with backlash have the same problem.</p>"},{"location":"troubleshooting/calibration/#mechanical-problems","title":"Mechanical Problems","text":"<p>If your rotor is not free to move, or has a significant load on it, then calibration can fail. Calibration will work with many kinds of reducers attached, but eventually the friction and stiction will be more than the process can manage. In some cases you can increase the power used during the lock-in phase of calibration by passing an extra option to <code>moteus_tool --calibrate</code>:</p> <pre><code>--cal-motor-power 5\n</code></pre> <p>The units are watts, and 5 is the default. You can increase this, but at higher values, you may run the risk of overheating your motor during the encoder calibration process.</p> <p>If a suitable power cannot be found, then it may be required to design the motor and controller as a sub-assembly which can be first calibrated and then attached to the reducer.</p>"},{"location":"troubleshooting/calibration/#the-bad-news","title":"The bad news","text":"<p>The bad news is that the error checking in the calibration process is not foolproof. i.e. it is possible for a setup that is broken to still report that calibration completed successfully. The two biggest indicators that it did not actually work are that the Kv value reported during calibration is grossly incorrect or that position or torque control do not work reliably. If either of those happen, you need to work through the above potential causes and rule them out one by one.</p>"},{"location":"troubleshooting/calibration/#the-good-news","title":"The good news","text":"<p>The good news is that if you have a working motor, an appropriate magnet, the magnet is rigidly affixed to the rotor and positioned properly, and your phase wire soldering followed proper technique, calibration should succeed virtually 100% of the time.</p>"},{"location":"troubleshooting/gate-driver-faults/","title":"Troubleshooting Gate Driver Faults","text":"<p>Certain types of electrical problems in moteus can result in the onboard MOSFET gate drivers declaring an error condition.  When that happens, moteus will report fault 33.  This document describes how to troubleshoot the issue.</p>"},{"location":"troubleshooting/gate-driver-faults/#identifying-the-cause","title":"Identifying the cause","text":"<p>To determine which fault the gate driver flagged, you need to look at the <code>drv8323</code> tree in tview or with <code>python -m moteus.moteus_tool -t 1 --read drv8323</code>.  Each fault has a different boolean value associated with it, and multiple can be flagged at the same time.  From a diagnostic perspective though, they boil down into two categories:</p>"},{"location":"troubleshooting/gate-driver-faults/#recoverable-faults","title":"Recoverable faults","text":"<p>The only fault type that, if repeatable, is easily recoverable is the <code>uvlo=true</code> fault.  This means that the gate driver identified the input supply voltage dropped below the minimum operation threshold.  It happens when moteus attempts to draw more power than the supply or battery can provide.  Depending upon the cause, there are several potential resolutions:</p> <p>moteus needs to output more torque/power: If the fault triggered but moteus was not yet applying sufficient torque for your application, then you must change your supply to be able to provide more power.  If the supply is a current limited lab supply, you could increase the current limit.  If it is a fixed current wall supply, you could switch to one with a higher power output.  If it is a battery, you could switch to one with a higher peak current rating.  It is also possible to occur due to poor supply wiring, i.e. if the resistance of the supply power cables is too high.</p> <p>moteus should not attempt to draw that much power: If moteus was attempting to apply more torque or power than is desirable, there are two limits which can be adjusted.</p> <ol> <li><code>servo.max_current_A</code> - This will determine the maximum phase current moteus can output and will correspond to the maximum amount of torque it can output.  This does not directly correlate with supply power, as the supply power required also scales linearly with the motor velocity.  However, it is good to ensure this is not set larger than it needs to be.</li> <li><code>servo.max_power_W</code> - This will determine the maximum amount of power moteus can output to the motor, and thus roughly the amount of supply power it can consume.  If using a power supply with known voltage and current capability, you can set this to be some fraction of that power to leave sufficient margin.</li> </ol>"},{"location":"troubleshooting/gate-driver-faults/#unrecoverable-faults","title":"Unrecoverable faults","text":"<p>Most non-uvlo faults the gate driver reports indicate that the controller has suffered electrical damage.  Most of the reasons are laid out in the electrical section of the user guide:</p> <ul> <li>Using moteus: Electrical</li> </ul> <p>i.e. poor wire construction can result in micro-arcing which further causes large voltage transients either at the supply terminals, or the motor phase terminals.  Lack of inrush current management also results in large voltage transients at the supply terminals.  Poor strain relief of XT30 connectors, once again, can cause micro-arcing and large voltage transients.</p> <p>In these cases, it may be possible to recover the controller by replacing components, but doing so requires moderate to advanced SMT rework capabilities that are beyond most users.  Usually the appropriate action is to identify which of the electrical installation guidelines were not adhered to, address them, then replace the controller with a new one.</p>"},{"location":"troubleshooting/limited-torque/","title":"Troubleshooting Limited Torque","text":"<p>If moteus is able to control a motor, but is unable produce sufficient torque for your application's needs, this post describes diagnostic steps.</p>"},{"location":"troubleshooting/limited-torque/#outline","title":"Outline","text":"<p>There are a few main classes of things that can limit torque.</p> <ol> <li>Misconfiguration:  Things that fall into this category include PID constants that are not tuned or an overly aggressive current limit or thermal limit.</li> <li>Under-cooled controller or motor: If the controller and motor are properly sized for the application, they may still require thermal management to achieve those goals.</li> <li>Under-sized controller or motor: If thermal management alone is insufficient, or is not practical, then either a larger controller or larger motor may be required.</li> <li>Insufficient supply voltage: With low-Kv motors, it is possible for supply voltage to be a limiting factor.</li> </ol>"},{"location":"troubleshooting/limited-torque/#diagnosing","title":"Diagnosing","text":"<p>First you need to understand which of the above three classes you are in.  To do so, there are some possible diagnostics and other things to check.</p>"},{"location":"troubleshooting/limited-torque/#output-limit-reasons","title":"Output Limit Reasons","text":"<p>As of firmware version 2025-07-21, the firmware will report if a factor is limiting the output current via the \"fault\" register while in position mode.  The set of possible values are:</p> <ul> <li>96 max_velocity: Maximum velocity: If the observed velocity exceeds the configured maximum velocity, torque is limited in the direction that would cause the velocity to increase.  This is configured with <code>servo.max_velocity</code>.</li> <li>97 max_power: Maximum power: The total power of the output is limited through a combination of a board power profile and <code>servo.max_power_W</code>.  See this post for more.</li> <li>98 BEMF: Maximum system voltage: The supply voltage, combined with the back EMF of the motor and the phase resistance does not permit more current to be applied.</li> <li>99 max_current: Maximum current: There is a system wide maximum output phase current that is configured in <code>servo.max_current_A</code>.</li> <li>100 fault_temperature:  Temperature: The onboard FET temperature sensor can limit the output current.  This threshold is set in the current firmware with <code>servo.fault_temperature</code>/<code>servo.temperature_margin</code>.</li> <li>101 motor_temperature: Temperature: The motor temperature sensor can also limit the output current.  This is configured in <code>servo.motor_fault_temperature</code>/<code>servo.motor_temperature_margin</code>.</li> <li>102 max_torque: Maximum torque: With each position mode command, the client can specify a maximum torque to use.  If the combination of the onboard PID and commanded feedforward torque exceeds this, then limiting occurs.</li> <li>103 position_bounds: Position bounds: If the current position is outside of <code>servopos.position_min</code> and <code>servopos.position_max</code>, then torque is limited in the direction that would push the motor further outside the bounds.</li> </ul>"},{"location":"troubleshooting/limited-torque/#other-possibilities","title":"Other possibilities","text":"<p>If none of the above limiting flags are present, then the remaining options include:</p>"},{"location":"troubleshooting/limited-torque/#not-stiff-enough-pid-tuning","title":"Not stiff enough PID tuning","text":"<p>The torque applied by moteus (aside from any feedforward torque), is determined by the error between the desired and measured position and the error between the desired and measured velocity.  If the constants controlling this process are too low, then moteus will apply very little torque even for large errors.</p> <p>One common way this occurs with moteus is:</p> <ol> <li>A PID tuning is created</li> <li>Later, a reducer is configured using <code>motor_position.rotor_to_output_ratio</code></li> <li>Wow, now moteus doesn't output much torque</li> </ol> <p>The important point to note here is that the PID terms for the moteus control loop are measured at the output of any reducer.  Thus if kp=1, that means apply 1Nm of torque at the output for 1 revolution of error at the output.  With a reducer, that means the effective gains at the rotor are reduced by the reduction squared.</p> <p>So, after configuring a reducer, you can either re-tune the PID gains, or increase the gains by the square of the reduction.</p> <p>Sample:</p> <pre><code>servo.pid_position.kp = 4\nservo.pid_position.kd = 0.05\nmotor_position.rotor_to_output_ratio = 1\n</code></pre> <p>You test this and it works great.  Then you configure the 8x reducer which was always present.</p> <pre><code>motor_position.rotor_to_output_ratio = 0.125\n</code></pre> <p>And now all of a sudden the controller barely does anything at all. To have equivalent stiffness, you now need to increase the kp and kd gains by a factor of <code>8 ** 2 = 64</code>.</p> <pre><code>servo.pid_position.kp = 256\nservo.pid_position.kd = 3.2\n</code></pre>"},{"location":"troubleshooting/limited-torque/#invalidated-calibration","title":"Invalidated calibration","text":"<p>If your calibration was invalidated, it can result in lack of torque.  Invalidation can happen for any of the reasons in the calibration troubleshooting guide, and include:</p> <ul> <li>A sense magnet that was not rigidly affixed to the rotor, say because adhesive not used at a joint</li> <li>A sense magnet that exceeded its rated temperature</li> <li>The controller mounting shifted</li> </ul> <p>To test these hypotheses, re-calibrate the motor and check again.  If the problem is resolved, then you need to identify which of the above issues was the most likely culprit and resolve it.</p>"},{"location":"troubleshooting/limited-torque/#other-limiting-like-things","title":"Other \"limiting like things\"","text":"<p>There are some \"limiting-like\" features that do not report through the fault code mechanism.  If position bounds are configured, the control position is limited to stay within those bounds.  This does not directly limit torque, so is not reported via this mechanism.</p> <p>Similarly, if the commanded velocity exceeds either the velocity limit, <code>velocity.max_velocity</code>, or <code>servo_stats.motor_max_velocity</code>, then it is truncated to stay within.  These limits are not reported via the fault code mechanism.</p>"},{"location":"troubleshooting/limited-torque/#resolution","title":"Resolution","text":"<p>If the error was mis-configuration, fix it and you are done.</p> <p>If the error was not mis-configuration, then the resolution depends upon what was causing the limiting.</p>"},{"location":"troubleshooting/limited-torque/#thermal-limiting","title":"Thermal limiting","text":"<p>If the limit was thermal, then your options are:</p> <ol> <li>apply cooling to whatever was hot</li> <li>use a bigger controller or motor for whatever was hot</li> <li>use a reducer, or if already using a reducer, use a bigger one</li> </ol>"},{"location":"troubleshooting/limited-torque/#maximum-current","title":"Maximum current","text":"<p>If you hit the controller maximum current limit, then your options are:</p> <ol> <li>use a different motor</li> <li>use a controller with a higher current limit</li> <li>use a reducer, or if already using a reducer, use a bigger one</li> </ol>"},{"location":"troubleshooting/limited-torque/#bemf-or-servo_statsmotor_max_velocity","title":"BEMF or <code>servo_stats.motor_max_velocity</code>","text":"<p>If you are limited by the back EMF of your motor, then your options are:</p> <ol> <li>use a higher supply voltage</li> <li>use a different motor with a higher Kv rating</li> </ol>"},{"location":"troubleshooting/limited-torque/#max-power","title":"max power","text":"<p>Here, your options are:</p> <ol> <li>configure a higher PWM frequency</li> <li>use a bigger controller</li> <li>use a different motor</li> <li>use a reducer, or if already using a reducer, use a bigger one</li> </ol>"},{"location":"troubleshooting/limited-torque/#resolution-caveats","title":"Resolution caveats","text":""},{"location":"troubleshooting/limited-torque/#reducers","title":"Reducers","text":"<p>If considering using a reducer or a bigger reducer, the biggest caveat is that the maximum speed will be decreased by a corresponding amount.</p> <p>Secondarily, most reducers have backlash and will add static and dynamic friction to your system and may have limits on maximum torque or speed that become limiters.</p>"},{"location":"troubleshooting/limited-torque/#pwm-frequency","title":"PWM frequency","text":"<p>If increasing the PWM frequency to improve peak power, this will also decrease the efficiency of moteus.  That will result in lower continuous output current and power ratings.</p>"},{"location":"troubleshooting/limited-torque/#cooling","title":"Cooling","text":"<p>The obvious downsides of cooling are noise, lower reliability, and increased power consumption even when under no load.</p>"},{"location":"troubleshooting/limited-torque/#moteus-performance-analysis-tool","title":"moteus performance analysis tool","text":"<p>If attempting to design a motor system to achieve a particular goal, it may be useful to use the moteus performance analysis too, which lets you vary these parameters and measure the resulting performance of the system.</p> <ul> <li>https://mjbots.github.io/moteus/mpat.html</li> <li>mpat blog post</li> </ul>"},{"location":"troubleshooting/no-motion/","title":"Troubleshooting No Motion","text":"<p>You sent a command to moteus, or ran a script, but nothing moved.  This article will describe what steps you can take to diagnose and resolve the issue.</p>"},{"location":"troubleshooting/no-motion/#using-tview","title":"Using tview","text":"<p>If you sent a <code>d pos</code> command from tview, there are a few possibilities.</p> <p>Invalid Syntax: If the diagnostic channel responds with an OK, then this is not the problem.  If it responds otherwise, then the error message will give you a clue as to the problem.  The syntax for the <code>d pos</code> command can be found in the diagnostic protocol reference manual.</p> <p>Position Mode Fault: If the diagnostic channel responded OK, then to identify the problem you must look at the current reported mode and fault status.  They will be present as the first two items in the <code>servo_stats</code> telemetry channel.  Common problems when first attempting control are:</p> <ul> <li>\"39 (outside bounds)\": <code>servopos.position_min</code> and <code>servopos.position_max</code> are either not configured, or the motor starting position is outside the configured bounds.  Setting either to <code>nan</code> will disable it.</li> <li>\"33 (gate driver fault)\": this indicates that the onboard MOSFET gate driver reported a fault.  To know which one, you will need to expand the <code>drv8323</code> telemetry channel.  The only \"easy\" problem to solve is <code>uvlo</code> which indicates that moteus attempted to draw more power than your supply could provide.</li> <li>\"43 (no position)\": the most common reason for this fault is that the controller has not been calibrated yet.  See the quick start section on calibration.</li> </ul> <p>Once the cause of the fault has been identified, it can be cleared by sending:</p> <p><code>d stop</code></p> <p>Then the command in question can be attempted again.</p>"},{"location":"troubleshooting/no-motion/#from-a-script-or-application","title":"From a script or application","text":"<p>If you have a python script, C++ application, or other tool which is commanding moteus and it does not move, there are a few tools you can use.</p> <p>Request and display the mode and fault: If your application does not already request and display the mode and fault it should do so.</p> <p>Log CAN-FD data: If the application cannot be modified or it is difficult to do so, you can either (a) if it is using the python library use the <code>--can-debug OUT.LOG</code> command flag to save a record of all frames sent and received or (b) attach a second CAN-FD adapter to the bus and use it to log data.</p> <p>Once you have data, it can be examined using <code>utils/decode_can_frame.py</code> to see what moteus is reporting.</p> <p>Problems may be the same as from the \"Using tview\" section above.</p> <p>Another common problem with applications using the register protocol (what the python and C++ library does), is watchdog timeouts.  For the register protocol, by default, moteus requires commands arrive at least every 100ms or it will enter mode 11, the timeout mode.  Once in this mode, a \"stop\" command must be sent to clear it.</p> <p>The watchdog timer configuration is described in the reference manual.</p>"},{"location":"troubleshooting/timeout-mode-11/","title":"moteus reports mode 11 - Timeout","text":"<p>After performing some initial validation using tview, maybe you port your motion profile to a python or C++ application to get ready for a deployment.  However, often users at this point will start seeing moteus enter mode 11, the timeout mode, after which it stops accepting commands and acts to damp motion.  This guide tells you why that happens and how to fix it.</p>"},{"location":"troubleshooting/timeout-mode-11/#rationale","title":"Rationale","text":"<p>moteus implements a \"watchdog timer\" for commands that arrive over CAN-FD.  Once any command is received, the next one must be received within a certain time period.  If it doesn't, then moteus will enter the timeout mode.</p> <p>There are a few reasons for this feature:</p> <ol> <li>Safety: In an actual deployment, moteus could have been commanded to make a large or fast movement indefinitely.  If your application crashes, or the computer hosting it is powered down, you probably don't want moteus continuing.</li> <li>Convenience: When testing an application, if you exit the application you typically want moteus to stop doing whatever it was doing as well.</li> </ol> <p>Once in the timeout mode, moteus will only leave it upon receiving a stop command.  This prevents moteus from resuming unexpectedly.</p> <p>When using diagnostic mode commands like when typing into the diagnostic channel console in tview, moteus defaults to an infinite watchdog duration for the sake of convenience.  This is why the problem most often appears after switching to a script.  Both the python and C++ library default to using the more efficient register mode commands.</p>"},{"location":"troubleshooting/timeout-mode-11/#fixes","title":"Fixes","text":"<p>If you get the timeout here are ways to resolve it:</p>"},{"location":"troubleshooting/timeout-mode-11/#disable-or-extend-the-timeout-duration","title":"Disable or extend the timeout duration","text":"<p>The length of time moteus waits is configurable at:</p> <pre><code>servo.default_timeout_s\n</code></pre> <p>(listed here in the reference)</p> <p>To disable it, use <code>nan</code>, otherwise specify a floating point number of seconds.</p>"},{"location":"troubleshooting/timeout-mode-11/#structure-your-application-to-send-commands-at-a-regular-interval","title":"Structure your application to send commands at a regular interval","text":"<p>To maintain the benefits of the watchdog, your application needs to continually send commands to moteus.  That means even when the application is waiting, it still needs to be sending commands.  Fortunately, for many moteus commands, if the target velocity was 0, you can keep sending the same command over and over again.</p> PythonC++ <pre><code># Don't do this:\n#  await asyncio.sleep(5)\n\n# Instead, do this:\nstart = time.time()\nwhile time.time() - start &lt; 5:\n  await c.set_position(velocity=0.0, query=True)\n  await asyncio.sleep(0.02)\n</code></pre> <pre><code>// Don't do this.\n//  ::usleep(1000000);\n\n// Instead, do this:\n#include &lt;chrono&gt;\n\ndouble get_time() {\n  using namespace std::chrono;\n  return duration&lt;double&gt;(system_clock::now().time_since_epoch()).count();\n}\n\nint main() {\n  // setup ...\n\n  const auto start = get_time();\n  while (get_time() - start &lt; 5) {\n    mjbots::moteus::PositionMode::Command cmd;\n    cmd.velocity = 0.0;\n    cmd.position = NaN;\n    c.SetPosition(cmd);\n\n    ::usleep(10000);\n  }\n\n  return 0;\n}\n</code></pre>"},{"location":"troubleshooting/timeout-mode-11/#a-combination-of-the-above-two","title":"A combination of the above two","text":"<p>It may be that even after restructuring your application to send commands more regularly, it makes sense to increase, but not disable the default watchdog timeout.</p>"}]}