// Copyright 2025 mjbots Robotic Systems, LLC.  info@mjbots.com
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#pragma once

#include <algorithm>
#include <cstdint>
#include <cstring>

namespace moteus {

// Configuration for BiSS-C frame extraction
struct BisscExtractConfig {
  uint8_t pin_bit_pos = 0;    // Bit position within sample (0-7 for 8-bit)
  uint8_t data_bits = 0;      // Number of data bits (1-64)
  uint8_t crc_bits = 6;       // Number of CRC bits (typically 6)
  bool store_debug = true;    // If false, skip storing start_bit_index/crc values
};

enum class BisscExtractError {
  kNone = 0,
  kStartBitNotFound = 1,
  kBufferTooSmall = 2,
  kCrcMismatch = 3,
};

// Result of BiSS-C frame extraction
struct BisscExtractResult {
  BisscExtractError error = BisscExtractError::kNone;

  uint64_t data_value = 0;
  bool error_flag = false;    // BiSS-C error bit (true = no error)
  bool warning_flag = false;  // BiSS-C warning bit (true = no warning)
  uint32_t crc_received = 0;
  uint32_t crc_computed = 0;
  int start_bit_index = -1;   // Index where START bit was found
};

// Protocol constants
static constexpr uint32_t kBisscMaxAckBits = 20;
static constexpr uint32_t kBisscMaxStartBits = 1;
static constexpr uint32_t kBisscMaxStatusBits = 2;  // Error + Warning

// Magic multiplier for MSB-first bit collection from 4 bytes.
// Collects bits from positions 0, 8, 16, 24 into positions 27, 26, 25, 24.
// After >> 24, gives bits in correct MSB-first order.
static constexpr uint32_t kBisscBitCollectMSB = 0x08040201u;

// CRC-6 lookup table for polynomial 0x43 (x^6 + x + 1)
// Generated by processing each 6-bit input value through the polynomial.
// Reference: RLS application note E201D02 "Decoding the BiSS information"
static constexpr uint8_t kBisscCrc6Table[64] = {
    0x00, 0x03, 0x06, 0x05, 0x0C, 0x0F, 0x0A, 0x09,
    0x18, 0x1B, 0x1E, 0x1D, 0x14, 0x17, 0x12, 0x11,
    0x30, 0x33, 0x36, 0x35, 0x3C, 0x3F, 0x3A, 0x39,
    0x28, 0x2B, 0x2E, 0x2D, 0x24, 0x27, 0x22, 0x21,
    0x23, 0x20, 0x25, 0x26, 0x2F, 0x2C, 0x29, 0x2A,
    0x3B, 0x38, 0x3D, 0x3E, 0x37, 0x34, 0x31, 0x32,
    0x13, 0x10, 0x15, 0x16, 0x1F, 0x1C, 0x19, 0x1A,
    0x0B, 0x08, 0x0D, 0x0E, 0x07, 0x04, 0x01, 0x02,
};

// Compute CRC-6 for BiSS-C data using table-based approach.
// Polynomial: x^6 + x + 1 (0x43)
// Reference: RLS application note E201D02 "Decoding the BiSS information"
inline uint32_t ComputeBisscCRC(uint64_t data, uint8_t data_bits, uint8_t crc_bits) {
  if (crc_bits == 0) { return 0; }

  // Only CRC-6 is supported with the lookup table
  if (crc_bits != 6) {
    // Fallback to bitwise computation for non-standard CRC sizes.
    //
    // Note, this is almost certain too slow to use in firmware, and
    // is included just for reference.
    const uint32_t polynomial = (1 << crc_bits) | 1;
    uint32_t crc = 0;
    for (int i = data_bits - 1; i >= 0; i--) {
      const bool bit = (data >> i) & 1;
      const bool msb = (crc >> (crc_bits - 1)) & 1;
      crc <<= 1;
      if (bit ^ msb) {
        crc ^= polynomial;
      }
    }
    return crc & ((1 << crc_bits) - 1);
  }

  // Table-based CRC-6 using fixed shift amounts. Upper zero bits act as
  // implicit leading zero padding. For data_bits <= 30 (common case),
  // skip the first 5 lookups since they just process zeros.
  uint8_t crc = 0;
  if (data_bits > 30) {
    crc = kBisscCrc6Table[(data >> 54) & 0x3F];
    crc = kBisscCrc6Table[((data >> 48) & 0x3F) ^ crc];
    crc = kBisscCrc6Table[((data >> 42) & 0x3F) ^ crc];
    crc = kBisscCrc6Table[((data >> 36) & 0x3F) ^ crc];
    crc = kBisscCrc6Table[((data >> 30) & 0x3F) ^ crc];
  }
  crc = kBisscCrc6Table[((data >> 24) & 0x3F) ^ crc];
  crc = kBisscCrc6Table[((data >> 18) & 0x3F) ^ crc];
  crc = kBisscCrc6Table[((data >> 12) & 0x3F) ^ crc];
  crc = kBisscCrc6Table[((data >> 6) & 0x3F) ^ crc];
  crc = kBisscCrc6Table[(data & 0x3F) ^ crc];
  return crc;
}

namespace detail {

// Extract a single bit from an 8-bit sample
inline uint32_t ExtractBit(uint8_t sample, uint8_t pin_bit_pos) {
  return (sample >> pin_bit_pos) & 1;
}

// Find the START bit by scanning for LOW->HIGH transition after ACK.
// BiSS-C frame: [HIGH idle] -> [LOW ACK] -> [HIGH START] -> data
// Returns index of START bit, or -1 if not found.
inline int FindStartBit(const uint8_t* buffer, uint32_t buffer_size,
                        uint8_t pin_bit_pos, uint32_t max_search) {
  const uint32_t search_limit = std::min(max_search, buffer_size);
  const uint8_t* ptr = buffer;
  const uint8_t* const end = buffer + search_limit;
  const uint32_t mask = 1u << pin_bit_pos;

  // Phase 1: Find the first 0 (entering ACK).  This is typically
  // short, so no batching is needed
  while (ptr < end && (*ptr & mask)) { ptr++; }
  if (ptr >= end) { return -1; }

  // Phase 2: Find the first 1 after the ACK, which will be the START
  // bit.  This can be longer, so we use 4-byte batching.

  // Before beginning the batch search, align to 4-byte boundary.
  while ((reinterpret_cast<uintptr_t>(ptr) & 3) && ptr < end) {
    if (*ptr & mask) { return static_cast<int>(ptr - buffer); }
    ptr++;
  }

  // Batch check 4 bytes at a time
  const uint32_t mask4 = mask * 0x01010101u;
  const uint32_t* ptr32 = reinterpret_cast<const uint32_t*>(ptr);
  const uint32_t* const end32 = reinterpret_cast<const uint32_t*>(
      reinterpret_cast<uintptr_t>(end) & ~3u);

  while (ptr32 < end32) {
    const uint32_t samples = *ptr32;
    const uint32_t masked = samples & mask4;
    if (masked) {
      // CTZ gives lowest set bit position; divide by 8 for the byte
      // offset.
      const uint32_t byte_offset = __builtin_ctz(masked) / 8;
      return static_cast<int>(
          reinterpret_cast<const uint8_t*>(ptr32) + byte_offset - buffer);
    }
    ptr32++;
  }

  // Check remaining bytes
  ptr = reinterpret_cast<const uint8_t*>(ptr32);
  while (ptr < end) {
    if (*ptr & mask) { return static_cast<int>(ptr - buffer); }
    ptr++;
  }

  return -1;
}

// Extract data bits using the multiplication trick for 4-bit batches.
// Handles alignment and remainder bits.
// Optimized: uses 32-bit accumulation for data_bits <= 32 (most encoders).
inline uint64_t ExtractDataBits(const uint8_t* buffer, uint32_t start_index,
                                 uint8_t data_bits, uint8_t pin_bit_pos) {
  const uint8_t* ptr8 = &buffer[start_index];

  // Pre-compute mask for isolating target bit in all 4 bytes
  const uint32_t pin_mask4 = (1u << pin_bit_pos) * 0x01010101u;

  // To save cycles when using a data type of 32 bits or less, we
  // implement two paths, one for 32 bit data and one for 64 bit data.
  // Those paths are otherwise identical, so this local lambda is just
  // templated on the accumulator type.
  const auto extract = [&]<typename T>() -> T {
    T accumulator = 0;
    uint32_t remaining = data_bits;
    const uint8_t* p = ptr8;

    // Process 4 samples at a time using our multiplication trick.
    // Use memcpy for potentially unaligned access.
    while (remaining >= 4) {
      uint32_t samples;
      std::memcpy(&samples, p, 4);
      p += 4;
      const uint32_t masked = samples & pin_mask4;
      const uint32_t normalized = masked >> pin_bit_pos;
      const uint32_t four_bits = (normalized * kBisscBitCollectMSB) >> 24;

      accumulator = (accumulator << 4) | four_bits;
      remaining -= 4;
    }

    // Handle remaining 1-3 samples.
    while (remaining > 0) {
      accumulator = (accumulator << 1) | ExtractBit(*p++, pin_bit_pos);
      remaining--;
    }

    return accumulator;
  };

  // Use 32 bit accumulator for <= 32 bits and 64 bit otherwise.
  if (data_bits <= 32) {
    return extract.template operator()<uint32_t>();
  }
  return extract.template operator()<uint64_t>();
}

// Extract BiSS-C CRC bits
//
// Optimized for CRC-6: uses multiplication trick for first 4 bits,
// then 2 more.
inline uint32_t ExtractCrcBits(const uint8_t* buffer, uint32_t start_index,
                                uint8_t crc_bits, uint8_t pin_bit_pos) {
  const uint8_t* ptr8 = &buffer[start_index];

  // Optimized path for CRC-6 (most common)
  if (crc_bits == 6) {
    // Extract first 4 bits using multiplication trick
    uint32_t samples;
    std::memcpy(&samples, ptr8, 4);
    const uint32_t pin_mask4 = (1u << pin_bit_pos) * 0x01010101u;
    const uint32_t masked = samples & pin_mask4;
    const uint32_t normalized = masked >> pin_bit_pos;

    // Invert: CRC bits are inverted in BiSS-C
    const uint32_t four_bits =
        ((normalized * kBisscBitCollectMSB) >> 24) ^ 0x0f;

    // Extract remaining 2 bits
    const uint32_t bit4 = ((ptr8[4] >> pin_bit_pos) & 1) ^ 1;
    const uint32_t bit5 = ((ptr8[5] >> pin_bit_pos) & 1) ^ 1;

    // Combine: four_bits has bits 0-3, bit4 is bit 4, bit5 is bit 5
    return (four_bits << 2) | (bit4 << 1) | bit5;
  }

  // Fallback for non-6-bit CRC
  uint32_t crc_received = 0;
  for (uint32_t i = 0; i < crc_bits; i++) {
    const uint32_t bit = ExtractBit(*ptr8++, pin_bit_pos) ^ 1;
    crc_received = (crc_received << 1) | bit;
  }
  return crc_received;
}

}  // namespace detail

// Main extraction function for BiSS-C frame from 8-bit samples.
//
// Buffer layout after DMA capture:
//   [idle bits] [ACK bits (LOW)] [START bit (HIGH)] [CDS] [data bits] [E] [W] [CRC bits]
//
// The extraction:
// 1. Finds the START bit by detecting LOW->HIGH transition after ACK
// 2. Extracts the data bits (MSB-first)
// 3. Extracts the Error and Warning bits, they are inverted, so LOW is faulty
// 4. Extracts the CRC bits, these are also inverted
// 5. Validates the CRC
inline BisscExtractResult ExtractBisscFrame(
    const uint8_t* buffer,
    uint32_t buffer_size,
    const BisscExtractConfig& config) {

  BisscExtractResult result;

  // Find the START bit if present
  const uint32_t max_search = kBisscMaxAckBits + 5;
  const int start_bit_index = detail::FindStartBit(
      buffer, buffer_size, config.pin_bit_pos, max_search);

  if (start_bit_index < 0) {
    result.error = BisscExtractError::kStartBitNotFound;
    return result;
  }

  // Calculate indices - all derived from start_bit_index and data_bits
  const uint32_t data_bits = config.data_bits;
  const uint32_t data_start = static_cast<uint32_t>(start_bit_index) + 2;
  const uint32_t status_start = data_start + data_bits;
  const uint32_t crc_start = status_start + 2;
  const uint32_t total_needed = crc_start + config.crc_bits;

  if (total_needed > buffer_size) {
    result.error = BisscExtractError::kBufferTooSmall;
    return result;
  }

  const uint8_t pin_bit_pos = config.pin_bit_pos;

  const uint64_t data_value = detail::ExtractDataBits(
      buffer, data_start, data_bits, pin_bit_pos);

  const uint32_t raw_error =
      detail::ExtractBit(buffer[status_start], pin_bit_pos);
  const uint32_t raw_warning =
      detail::ExtractBit(buffer[status_start + 1], pin_bit_pos);

  // Extract and validate the CRC.
  const uint32_t crc_received = detail::ExtractCrcBits(
      buffer, crc_start, config.crc_bits, pin_bit_pos);

  const uint64_t crc_input =
      (data_value << 2) | (raw_error << 1) | raw_warning;
  const uint32_t crc_computed =
      ComputeBisscCRC(crc_input, data_bits + 2, config.crc_bits);

  // Validate CRC
  if (crc_received != crc_computed) {
    result.error = BisscExtractError::kCrcMismatch;
    if (config.store_debug) {
      result.start_bit_index = start_bit_index;
      result.crc_received = crc_received;
      result.crc_computed = crc_computed;
    }
    return result;
  }

  // Success - write essential result fields
  result.data_value = data_value;
  result.error_flag = (raw_error == 0);
  result.warning_flag = (raw_warning == 0);

  // Debug fields - skip in production for faster ISR
  if (config.store_debug) {
    result.start_bit_index = start_bit_index;
    result.crc_received = crc_received;
    result.crc_computed = crc_computed;
  }

  return result;
}

}  // namespace moteus
